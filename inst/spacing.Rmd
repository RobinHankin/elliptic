---
title: "Some thoughts on whitespace in R code"
author: "Robin Hankin"
date: "2025-08-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
<style>
  .col2 {
    columns: 2 200px;         /* number of columns and width in pixels*/
    -webkit-columns: 2 200px; /* chrome, safari */
    -moz-columns: 2 200px;    /* firefox */
  }
  
  .col-break {
    break-before: column;       /* modern browsers */
    -webkit-column-break-before: always; /* Safari/Chrome */
    -moz-column-break-before: always;    /* Firefox */
  }
</style>


When you are expressing mathematical ideas on paper, you want the
appearance of what you write to be easy to understand mathematically.
Conventional typesetting, and in particular TeX, does a very good job
of this.  This document discusses ways of making R expressions easy to
parse using monospaced font.  The tidyverse team states:

"All style guides are fundamentally opinionated"

Here, I put out some of my own opinions, but attempt to justify them.
Tidyverse lore is to include spaces pretty much everywhere: around
arithmetic operators, after commas, and around relations such as `=`
and `>=`.  Now I don't think this is optimal, at least for many of the
expressions I work with.  I present below several versions of an R
expression, arranged from least spaces to most spaces.

The RStudio IDE gives style warnings if the whitespace does not
conform to its guidelines.  Version 387 of RStudio appears to require
a space around "`+`" but not "`*`" (previous versions required space
round both).  I will start with the trivial case of unary operators:

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: +1  ✅
2: + 1 ❌
```
</p><div class="col-break"></div>
Tidyverse approves of option 1 but not option 2.  This is correct IMO:
unary operators are tightly bound to their argument.
<br><br></p></div>

TeX recognises this and typesets the space after the `+` differently
in "$+1$" and "$1+1$".  It is in fact quite difficult to convince TeX
to typeset copy such as the chess "win, draw, loss" notation
[something like "$\mathord{+}3\ \mathord{=}4\ \mathord{-}5$", which
would mean 3 wins, 4 draws and 5 losses.  The difficulty is persuading
TeX to treat the equals sign and the minus sign as unary operators].

For binary operators `+` and `*` we have slightly different rules
under RStudio:

<div class="col2">
```
1: 2+2   ❌
2: 2 + 2 ✅
1: 2*2   ✅
2: 2 * 2 ✅
```
</p><div class="col-break"></div><p>
The mandatory spaces around `+` make sense as addition has low
priority.  Optional spaces around `*` also make sense because of
multiplication's having intermediate priority.
<br><br></p></div>

[it is probably worth pointing out here that `2* 2` and `2 *2` draw
warnings about "inconsistent spacing"].  I have no preference for
spaces or no spaces either, so long as consistency is maintained.  For
something like `-a*b`, though, it doesn't matter whether we parse this
as `(-a)*b` or `-(a*b)`, for both are equivalent to `(-1)*a*b` and
associativity ensures that the two interpretations are identical.

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: -4*7    ✅
2: - 4*7   ❌
3: -4 * 7  ✅
4: - 4 * 7 ❌
```
</p><div class="col-break"></div><br>
The warnings are generated by the space after the minus sign.  This
only for minus sign (or indeed plus sign) when used as a unary
operator (for binary operators, see below).  My preference would
depend on context: option 3 is unambiguously $(-4)*7$, as opposed to option
1 which could be either that or $-(4*7)$.
<br><br></p></div>


The ambiguity for unary minus and multiplication is not the case for
powers, and the simplest example would be `-1^2`.  This is parsed as
`-(1^2)`:

```{r minusonesquared}
-1^2
```

This complicates the issue of spacing, at least if we are not going to
use parentheses:

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: -1^2    ✅
2: - 1^2   ❌
3: -1 ^ 2  ✅
4: - 1 ^ 2 ❌
```
</p><div class="col-break"></div><br>
Option 3 is definitely wrong, because it is visually parsed as
`(-1)^2`.  I would actually go for option 2 here, as this makes it
clear that that `1^2` is a unit.
<br><br></p></div>

The issue is at least somewhat less ambiguous if we consider binary
minus:

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: 1-2^2     ❌
2: 1 - 2^2   ✅
3: 1 - 2 ^ 2 ✅
```
</p><div class="col-break"></div><br>
Option 2 is the best here, emphasising the tightly-bound `2^2`.
<br><br></p></div>

So what happens if we want to multiply a positive number on the left
by a negative number on the right?

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: 2*-3    ✅
2: 2 * -3  ✅
3: 2 * - 3 ❌
```
</p><div class="col-break"></div><br>
The minus sign is tightly bound to the 3 on the right, so option
2 is the best, in agreement with RStudio.
<br><br></p></div>

We can now start thinking about the fact that `*` has higher priority
than `+`:

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: 1+2*3     ✅
2: 1 + 2*3   ✅
3: 1 + 2 * 3 ✅
```
</p><div class="col-break"></div><br>
Again, option 2 is the best, emphaising the unit `2*3`.
<br><br></p></div>

In passing, note that `1+2 * 3` is **definitely wrong**: as a general
rule, spacing around an operator should indicate low precedence for
that operator.  Maybe there should be a "cut-off" precedence? So only
operators below this cut-off value should have spaces.  Anyway,
standard recommendation is for option 3, having each operator
surrounded by spaces (but observe that option 2 draws no complaints
from the Rstudio IDE).  However, because the precedence of `*` is
higher than that of `+`, one generally parses `1+2*3` as `1 + (2*3)`,
so my preference would be option 2. One wants the tightly-bound
expression, `2*3`, to be visually perceived as an isolated chunk that,
although it has some internal structure, is to be considered as a
unit. This echoes the use of radicals in chemistry; for example,
methanol is described as CH<sub>3</sub>OH [rather than, for example,
CH<sub>4</sub>O] because the OH radical often behaves as a discrete
and object that is difficult to split into an O and an H.  The fact
that it is actually composed of one atom of oxygen and one of hydrogen
is often irrelevant if not actively misleading.

How might this reasoning be affected if the final number is negative?

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: 1+2*-3     ❌
2: 1 + 2 * -3 ✅
```
</p><div class="col-break"></div><br>
We see Rstudio's preference for spaces which is technically OK but
frankly I would prefer brackets here and would plump for `1 + 2*(-3)`
<br><br></p></div>


And now we can consider three different binary operators with
different priorities:

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: 1+2*3^4       ❌
2: 1 + 2*3^4     ✅
3: 1 + 2 * 3^4   ✅
4: 1 + 2 * 3 ^ 4 ✅
```
</p><div class="col-break"></div><br>
My preference would be option 3, as the `3^4` is the highest
priority.  However, it is entirely reasonably to view `2*3^4` as an
indivisible entity, and if so then option 2 would be the best.
<br><br></p></div>

If we change the sign of the 4 then other issues arise:

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: 1+2*3^-4        ❌
2: 1 + 2*3^-4      ✅
3: 1 + 2 * 3^-4    ✅
4: 1 + 2 * 3 ^ -4  ✅
5: 1 + 2 * 3 ^ - 4 ❌
```
</p><div class="col-break"></div><br>
we should be explicit that a unary operator does not require a
space after it (`+ 3` looks *terrible*; option 5 is an abomination).
Rstudio complains about options 1 and 5.  My favourite would be 3.
<br><br></p></div>

Now let's think about parentheses.  The whole point of parentheses is
to subvert the standard arithmetic rules of precedence.

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: (1+2)*3     ❌
2: (1 + 2)*3   ✅
3: (1+2) * 3   ❌
4: (1 + 2) * 3 ✅
```
</p><div class="col-break"></div><br>
Option 3 would be the best, as `1+2` is the most tightly bound
expression.  Options 2 and 4, having the space around `+`, are poor
because they distract from this.  I would go for option 3 here,
against RStudio's advice.
<br><br></p></div>


<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: c(a=1,b=2)      ❌
2: c(a=1, b=2)     ❌
3: c(a=1 , b=2)    ❌
4: c(a = 1,b = 2)  ✅
5: c(a = 1, b = 2) ✅
```
</p><div class="col-break"></div><br>
We see, interestingly, that a space after a comma is not
required for RStudio approval.  I believe that the atoms of this
expression are `a=1` and `b=2` so there should be no space around the
equals sign.  I am split between options 2 and 3 on this one.
<br><br></p></div>


Now consider functions such as `exp()` or `sin()`.  The `elliptic`
package contains the following expressions

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: r*pi*2i*exp(pi*2i*x)           ✅
2: r*pi*2i * exp(pi*2i*x)         ✅
3: r * pi * 2i * exp(pi*2i*x)     ✅
4: r*pi*2i * exp(pi * 2i * x)     ✅
5: r * pi * 2i * exp(pi * 2i * x) ✅
```
</p><div class="col-break"></div><br>
None of these raise a warning.  My preference would be for option
2, and indeed that is what copilot suggests.
<br><br></p></div>

The issue of complex numbers is interesting here.

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}
1: c(a=1,b=2+3i)      ❌
2: c(a=1, b=2+3i)     ❌
3: c(a=1 , b=2+3i)    ❌
4: c(a = 1,b = 2+3i)  ✅
5: c(a = 1, b = 2+3i) ✅
```
</p><div class="col-break"></div><br>
`2+3i` is more tightly bound than `a=1` so I think that a space around
the second `=` is needed here.  Option 5.
<br><br></p></div>


Mixing complex arguments and longer variable names is also problematic:


<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}      
1: c(2.3+0.23i,long_argument=TRUE)      ❌
2: c(2.3+0.23i, long_argument=TRUE)     ❌
3: c(2.3 + 0.23i, long_argument = TRUE) ✅
```
</p><div class="col-break"></div><br>
I prefer version `2`.  I think that `2.3+0.23i` is a unit, and
`long_argument=TRUE` is a unit, both being about equally tightly
bound.
<br><br></p></div>

It's probably worth pointing out that minus operator, being
nonassociative [that is, $a-(b-c)\neq (a-b)-c$] requires extra
bracketing:

<div class="col2"><p>
```{r, eval=FALSE, echo=TRUE, asis=TRUE}      
1: z-1.7+3i
2: z - 1.7+3i
3: z - (1.7-3i)
```
</p><div class="col-break"></div><br>
All three versions are algebraically identical.  Version `2` is
*definitely wrong* as it is parsed visually as `z - (1.7+3i)`.
<br><br></p></div>



