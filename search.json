[{"path":"https://robinhankin.github.io/elliptic/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor covenant code of conduct","title":"Contributor covenant code of conduct","text":"members, contributors, leaders wish make participation community pleasant productive experience everyone. try act interact ways contribute open, welcoming, inclusive, healthy community. assume good faith, per WP:AGF. Examples behaviour contributes positive environment community include: Demonstrating empathy kindness toward people Communicating respectfully differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community","code":""},{"path":"https://robinhankin.github.io/elliptic/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to elliptic","title":"Contributing to elliptic","text":"Thank considering contributing elliptic! interest making project better appreciated.","code":""},{"path":"https://robinhankin.github.io/elliptic/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of conduct","title":"Contributing to elliptic","text":"Please read adhere Code Conduct maintain safe, welcoming, inclusive environment.","code":""},{"path":"https://robinhankin.github.io/elliptic/CONTRIBUTING.html","id":"types-of-contributions","dir":"","previous_headings":"","what":"Types of contributions","title":"Contributing to elliptic","text":"welcome various forms contributions: Bug Reports: Feel free report bugs encounter. Documentation: Typos, clarity issues, missing guides—-help welcome . Feature Discussions/Requests: Got idea? Open issue discuss potential. Code Contributions: code contributions welcome, send pull request. Use-cases: using elliptic package, let know! ’s always great see applications mathematical software.","code":""},{"path":"https://robinhankin.github.io/elliptic/CONTRIBUTING.html","id":"using-co-authored-by-in-git-commits","dir":"","previous_headings":"","what":"Using co-authored-by in git commits","title":"Contributing to elliptic","text":"encourage use co-authored commits collaborative efforts. helps giving credit contributors work.","code":"Co-authored-by: name <name@example.com> Co-authored-by: another-name <another-name@example.com>"},{"path":"https://robinhankin.github.io/elliptic/CONTRIBUTING.html","id":"development","dir":"","previous_headings":"","what":"Development","title":"Contributing to elliptic","text":"contributions make project better everyone. Thank participating! Also don’t forget recreate readme file: {r eval=FALSE} devtools::build_readme()","code":""},{"path":"https://robinhankin.github.io/elliptic/CONTRIBUTING.html","id":"tests","dir":"","previous_headings":"Development","what":"Tests","title":"Contributing to elliptic","text":"Tests checks run CI, however locally one can use:","code":"Rscript -e 'devtools::test()'"},{"path":"https://robinhankin.github.io/elliptic/CONTRIBUTING.html","id":"documentation","dir":"","previous_headings":"Development > Tests","what":"Documentation","title":"Contributing to elliptic","text":"Ideally change documented. Major changes vignettes.","code":""},{"path":"https://robinhankin.github.io/elliptic/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin K. S. Hankin. Author, maintainer.","code":""},{"path":"https://robinhankin.github.io/elliptic/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"R. K. S. Hankin 2006. Introducing elliptic, R package elliptic \t modular functions. Journal Statistical Software 15(7)","code":"@Article{,   title = {{Introducing elliptic, an R package for elliptic \t and modular functions}},   author = {{Robin K. S. Hankin}},   journal = {Journal of Statistical Software},   year = {2006},   month = {February},   volume = {15},   issue = {7}, }"},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Weierstrass and Jacobi Elliptic Functions","text":"elliptic function meromorphic complex function periodic two directions. , exist two nonzero complex numbers   whenever  defined; note carefully factors 2. two natural ways presenting elliptic functions: Weierstrass, Jacobi. Historically, Jacobi form first presented practically useful, Weierstrass form elegant (IMO). Terminology follows Abramowitz Stegun wherever possible.","code":""},{"path":"https://robinhankin.github.io/elliptic/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Weierstrass and Jacobi Elliptic Functions","text":"install recent stable version CRAN, use install.packages() R prompt: install current development version use devtools: load package use library(): package comes extensive detailed vignette; type vignette(\"elliptic\") R commandline.","code":"R> install.packages(\"elliptic\") R> devtools::install_github(\"RobinHankin/elliptic\") library(\"elliptic\")"},{"path":"https://robinhankin.github.io/elliptic/index.html","id":"the-package-in-use","dir":"","previous_headings":"","what":"The package in use","title":"Weierstrass and Jacobi Elliptic Functions","text":"Weierstrass elliptic function evaluated numerically P(), takes half periods . Thus elliptic functions can visualised using view():  Related functions include  (sigma()  (zeta()).","code":"z <- 0.3 + 0.2i omega1 <- 5+1i; omega2 <- 1+7i  # half-periods f <- function(z){P(z,Omega=c(omega1,omega2))} c(f(z),f(z + 10+2i), f(z + 2+14i))  # should be equal ## [1] 2.958647-7.100563i 2.958647-7.100563i 2.958647-7.100563i x <- seq(from=-4, to=4, len=200) y <- x z <- outer(x,1i*x, \"+\") f <- P(z, c(1+1i,2-3i)) par(pty=\"s\") view(x,y,f,real.contour=FALSE,drawlabel=FALSE,axes=FALSE,xlab=\"Re(z)\",ylab=\"Im(z)\", main=\"P(z,1+i,2-3i)\") axis(1,pos = -4) axis(2,pos = -4) lines(x=c(-4,4),y=c(4,4)) lines(y=c(-4,4),x=c(4,4))"},{"path":"https://robinhankin.github.io/elliptic/index.html","id":"jacobi-forms","dir":"","previous_headings":"","what":"Jacobi forms","title":"Weierstrass and Jacobi Elliptic Functions","text":"Jacobi’s elliptic functions implemented package standard names sn(), cn(), dn() etc. example:  Jacobi forms useful physics can use visualise potential flow rectangle:","code":"view(x,y,sn(z,m=6),real=FALSE,drawlabel=FALSE,axes=FALSE,xlab=\"Re(z)\",ylab=\"Im(z)\", main=\"The Jacobi sn() function\") axis(1,pos = -4,at=c(-4,-2,0,2,4)) axis(2,pos = -4,at=c(-4,-2,0,2,4)) lines(x=c(-4,4),y=c(4,4)) lines(y=c(-4,4),x=c(4,4)) n <- 300 K <- K.fun(1/2)  # aspect ratio f <- function(z){1i*log((z-1.7+3i)*(z-1.7-3i)/(z+1-0.3i)/(z+1+0.3i))} # position of source and sink x <- seq(from=-K,to=K,len=n) y <- seq(from=0,to=K,len=n) z <- outer(x,1i*y,\"+\")  view(x, y, f(sn(z,m=1/2)), nlevels=44, real.contour=TRUE, drawlabels=FALSE,      main=\"Potential flow in a rectangle\",axes=FALSE,xlab=\"\",ylab=\"\") rect(-K,0,K,K,lwd=3)"},{"path":"https://robinhankin.github.io/elliptic/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Weierstrass and Jacobi Elliptic Functions","text":"M Abramowitz IA Stegun (1965). Handbook Mathematical Functions. New York: Dover RKS Hankin (2006). “Introducing elliptic, R package elliptic modular functions”. Journal Statistical Software, 15:7 K Chandrasekharan (1985). Elliptic functions. Springer-Verlag","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/J.html","id":null,"dir":"Reference","previous_headings":"","what":"Various modular functions — J","title":"Various modular functions — J","text":"Modular functions including Klein's modular function J (aka Dedekind's   Valenz function J, aka Klein invariant function, aka Klein's   absolute invariant), lambda function, Delta.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/J.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Various modular functions — J","text":"","code":"J(tau, use.theta = TRUE, ...) lambda(tau, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/J.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Various modular functions — J","text":"tau \\(\\tau\\); assumed Im(tau)>0 use.theta Boolean, default TRUE meaning use     theta function expansion, FALSE meaning evaluate     g2 g3 directly ... Extra arguments sent either theta1() et seq,     g2.fun() g3.fun() appropriate","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/J.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Various modular functions — J","text":"K. Chandrasekharan 1985. Elliptic functions,  Springer-Verlag.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/J.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Various modular functions — J","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/J.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Various modular functions — J","text":"","code":"J(2.3+0.23i,use.theta=TRUE) #> [1] 12.01226+8.339351i  J(2.3+0.23i,use.theta=FALSE) #> [1] 12.01226+8.339351i   #Verify that J(z)=J(-1/z):  z <- seq(from=1+0.7i,to=-2+1i,len=20)  plot(abs((J(z)-J(-1/z))/J(z)))    # Verify that lambda(z) = lambda(Mz) where M is a modular matrix with b,c  # even and a,d odd:   M <- matrix(c(5,4,16,13),2,2)  z <- seq(from=1+1i,to=3+3i,len=100)  plot(lambda(z)-lambda(M %mob% z,maxiter=100))    #Now a nice little plot; vary n to change the resolution:  n <- 50  x <- seq(from=-0.1, to=2,len=n)  y <- seq(from=0.02,to=2,len=n)   z <- outer(x,1i*y,\"+\")  f <- lambda(z,maxiter=40)  g <- J(z)  view(x,y,f,scheme=04,real.contour=FALSE,main=\"try higher resolution\")   view(x,y,g,scheme=10,real.contour=FALSE,main=\"try higher resolution\")"},{"path":"https://robinhankin.github.io/elliptic/reference/K.fun.html","id":null,"dir":"Reference","previous_headings":"","what":"quarter period K — K.fun","title":"quarter period K — K.fun","text":"Calculates K.fun terms either \\(m\\) (K.fun())   \\(k\\) (K.fun.k()).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/K.fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"quarter period K — K.fun","text":"","code":"K.fun(m, strict=TRUE, maxiter=7, miniter=3)"},{"path":"https://robinhankin.github.io/elliptic/reference/K.fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"quarter period K — K.fun","text":"m Real complex parameter strict Boolean, default TRUE meaning return     error sequence converged exactly, FALSE     meaning return partial sum, warning maxiter Maximum number iterations miniter Minimum number iterations guard premature     exit addend zero exactly","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/K.fun.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"quarter period K — K.fun","text":"R. Coquereaux, . Grossman, B. E. Lautrup. Iterative method calculation Weierstrass elliptic function. IMA Journal Numerical Analysis, vol 10, pp119-128, 1990","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/K.fun.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"quarter period K — K.fun","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/K.fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"quarter period K — K.fun","text":"","code":"K.fun(0.09)  # AMS-55 give 1.60804862 in example 7 on page 581 #> [1] 1.608049  # next example not run because: (i), it needs gsl; (ii) it gives a warning. if (FALSE) { # \\dontrun{ K.fun(0.4,strict=F, maxiter=4) - ellint_Kcomp(sqrt(0.4)) } # }"},{"path":"https://robinhankin.github.io/elliptic/reference/P.laurent.html","id":null,"dir":"Reference","previous_headings":"","what":"Laurent series for elliptic and related functions — P.laurent","title":"Laurent series for elliptic and related functions — P.laurent","text":"Laurent series various functions","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/P.laurent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Laurent series for elliptic and related functions — P.laurent","text":"","code":"P.laurent(z, g=NULL, tol=0, nmax=80)     Pdash.laurent(z, g=NULL, nmax=80)     sigma.laurent(z, g=NULL, nmax=8, give.error=FALSE) sigmadash.laurent(z, g=NULL, nmax=8, give.error=FALSE)      zeta.laurent(z, g=NULL, nmax=80)"},{"path":"https://robinhankin.github.io/elliptic/reference/P.laurent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Laurent series for elliptic and related functions — P.laurent","text":"z Primary argument (complex) g Vector length two g=c(g2,g3) tol Tolerance give.error sigma.laurent(), Boolean default     FALSE meaning return computed value TRUE     return error (estimated sum absolute values     terms along minor long diagonal matrix) . nmax Number terms used (, sigma(), size     matrix used)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/P.laurent.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Laurent series for elliptic and related functions — P.laurent","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/P.laurent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Laurent series for elliptic and related functions — P.laurent","text":"","code":"sigma.laurent(z=1+1i,g=c(0,4)) #> [1] 0.9619402+1.038131i"},{"path":"https://robinhankin.github.io/elliptic/reference/WeierstrassP.html","id":null,"dir":"Reference","previous_headings":"","what":"Weierstrass P and related functions — WeierstrassP","title":"Weierstrass P and related functions — WeierstrassP","text":"Weierstrass elliptic function derivative, Weierstrass sigma function, Weierstrass zeta function","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/WeierstrassP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weierstrass P and related functions — WeierstrassP","text":"","code":"P(z, g=NULL, Omega=NULL, params=NULL, use.fpp=TRUE, give.all.3=FALSE, ...) Pdash(z, g=NULL, Omega=NULL, params=NULL, use.fpp=TRUE, ...) sigma(z, g=NULL, Omega=NULL, params=NULL, use.theta=TRUE, ...) zeta(z, g=NULL, Omega=NULL, params=NULL, use.fpp=TRUE, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/WeierstrassP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weierstrass P and related functions — WeierstrassP","text":"z Primary complex argument g Invariants g=c(g2,g3).  Supply exactly one     (g, Omega, params) Omega Half periods params Object class “parameters” (typically     provided  parameters()) use.fpp Boolean, default TRUE meaning calculate     \\(\\wp(z^C)\\) \\(z^C\\) congruent \\(z\\)     period lattice.  default means accuracy greater     large \\(z\\) deficiency slight     discontinuities may appear near parallelogram boundaries give..3 Boolean, default FALSE meaning return     \\(\\wp(z)\\) TRUE meaning return forms given     equation 18.10.5, p650.  Use TRUE check accuracy use.theta Boolean, default TRUE meaning use     theta function forms, FALSE meaning use Laurent     expansion.  Usually, theta function form faster,     always ... Extra parameters passed theta1() theta1dash()","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/WeierstrassP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Weierstrass P and related functions — WeierstrassP","text":"R. K. S. Hankin.  Introducing Elliptic, R package     Elliptic Modular Functions.  Journal Statistical Software,   Volume 15, Issue 7.  February 2006.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/WeierstrassP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Weierstrass P and related functions — WeierstrassP","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/WeierstrassP.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Weierstrass P and related functions — WeierstrassP","text":"package, function sigma() Weierstrass sigma   function.  number theoretic divisor function also known   “sigma”, see divisor().","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/WeierstrassP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weierstrass P and related functions — WeierstrassP","text":"","code":"## Example 8, p666, RHS: P(z=0.07 + 0.1i,g=c(10,2)) #> [1] -22.9745-63.05323i  ## Example 8, p666, RHS: P(z=0.1 + 0.03i,g=c(-10,2)) #> [1] 76.58833-50.50379i ## Right answer!  ## Compare the Laurent series, which also gives the Right Answer (tm):  P.laurent(z=0.1 + 0.03i,g=c(-10,2)) #> [1] 76.58833-50.50379i   ## Now a nice little plot of the zeta function: x <- seq(from=-4,to=4,len=100) z <- outer(x,1i*x,\"+\") view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=6,scheme=1)    #now figure 18.5, top of p643: p <- parameters(Omega=c(1+0.1i,1+1i)) #> Warning: Omega supplied not a primitive pair of half periods.  Function converting Omega to a primitive pair  n <- 40  f <- function(r,i1,i2=1)seq(from=r+1i*i1, to=r+1i*i2,len=n) g <- function(i,r1,r2=1)seq(from=1i*i+r1,to=1i*i+2,len=n)  solid.lines <-   c(     f(0.1,0.5),NA,     f(0.2,0.4),NA,     f(0.3,0.3),NA,     f(0.4,0.2),NA,     f(0.5,0.0),NA,     f(0.6,0.0),NA,     f(0.7,0.0),NA,     f(0.8,0.0),NA,     f(0.9,0.0),NA,     f(1.0,0.0)     ) dotted.lines <-   c(     g(0.1,0.5),NA,     g(0.2,0.4),NA,     g(0.3,0.3),NA,     g(0.4,0.2),NA,     g(0.5,0.0),NA,     g(0.6,0.0),NA,     g(0.7,0.0),NA,     g(0.8,0.0),NA,     g(0.9,0.0),NA,     g(1.0,0.0),NA     )  plot(P(z=solid.lines,params=p),xlim=c(-4,4),ylim=c(-6,0),type=\"l\",asp=1) lines(P(z=dotted.lines,params=p),xlim=c(-4,4),ylim=c(-6,0),type=\"l\",lty=2)"},{"path":"https://robinhankin.github.io/elliptic/reference/amn.html","id":null,"dir":"Reference","previous_headings":"","what":"matrix a on page 637 — amn","title":"matrix a on page 637 — amn","text":"Matrix coefficients Taylor series \\(\\sigma(z)\\) described page 636 tabulated page 637.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/amn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"matrix a on page 637 — amn","text":"","code":"amn(u)"},{"path":"https://robinhankin.github.io/elliptic/reference/amn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"matrix a on page 637 — amn","text":"u Integer specifying size output matrix","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/amn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"matrix a on page 637 — amn","text":"Reproduces coefficients \\(a_{mn}\\) page 637 according   recurrence formulae 18.5.7 18.5.8, p636.  Used equation   18.5.6.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/amn.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"matrix a on page 637 — amn","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/amn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"matrix a on page 637 — amn","text":"","code":"amn(12)   #page 637 #>                [,1]          [,2]          [,3]          [,4]          [,5] #>  [1,]  1.000000e+00 -1.000000e+00 -9.000000e+00  6.900000e+01  3.210000e+02 #>  [2,] -3.000000e+00 -1.800000e+01  5.130000e+02  3.358800e+04  2.808945e+06 #>  [3,] -5.400000e+01  4.968000e+03  2.575800e+05  2.001996e+07 -3.763754e+08 #>  [4,]  1.490400e+04  5.022000e+05  1.621004e+08 -9.465715e+09 -4.582619e+12 #>  [5,]  1.506600e+06  7.963304e+08 -1.449162e+11 -6.064864e+13 -1.066586e+16 #>  [6,]  2.388991e+09 -1.289960e+12 -3.833029e+14 -6.622754e+16 -6.183356e+19 #>  [7,] -3.869879e+12 -1.343957e+15 -3.420400e+17 -6.456986e+20 -7.998594e+22 #>  [8,] -4.031871e+15 -7.217225e+17 -5.620753e+21  2.223168e+23  2.541624e+27 #>  [9,] -2.165167e+18 -3.280432e+22  1.351517e+25  2.919678e+28  0.000000e+00 #> [10,] -9.841296e+22  1.334467e+26  2.027200e+29  0.000000e+00  0.000000e+00 #> [11,]  4.003401e+26  9.556987e+29  0.000000e+00  0.000000e+00  0.000000e+00 #> [12,]  2.867096e+30  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #>                [,6]          [,7]          [,8]          [,9]         [,10] #>  [1,]  1.608390e+05  1.416951e+06 -3.889467e+08  2.551458e+10 -7.647989e+12 #>  [2,] -4.184314e+07 -6.519780e+09 -4.851746e+11 -5.443070e+14 -8.643787e+16 #>  [3,] -2.104693e+11 -4.176750e+13 -1.919977e+16 -2.149281e+18  1.537431e+20 #>  [4,] -1.028311e+15 -3.496619e+17 -3.965155e+19  4.033242e+21  0.000000e+00 #>  [5,] -4.849558e+18 -7.341200e+20  1.517919e+23  0.000000e+00  0.000000e+00 #>  [6,] -9.637761e+21  5.055024e+24  0.000000e+00  0.000000e+00  0.000000e+00 #>  [7,]  1.388833e+26  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #>  [8,]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #>  [9,]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #> [10,]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #> [11,]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #> [12,]  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #>               [,11]         [,12] #>  [1,] -1.013917e+15 -1.558129e+17 #>  [2,]  4.570022e+17  0.000000e+00 #>  [3,]  0.000000e+00  0.000000e+00 #>  [4,]  0.000000e+00  0.000000e+00 #>  [5,]  0.000000e+00  0.000000e+00 #>  [6,]  0.000000e+00  0.000000e+00 #>  [7,]  0.000000e+00  0.000000e+00 #>  [8,]  0.000000e+00  0.000000e+00 #>  [9,]  0.000000e+00  0.000000e+00 #> [10,]  0.000000e+00  0.000000e+00 #> [11,]  0.000000e+00  0.000000e+00 #> [12,]  0.000000e+00  0.000000e+00"},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts basic periods to a primitive pair — as.primitive","title":"Converts basic periods to a primitive pair — as.primitive","text":"Given pair basic periods, returns primitive pair (optionally) unimodular transformation used.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts basic periods to a primitive pair — as.primitive","text":"","code":"as.primitive(p, n = 3, tol = 1e-05, give.answers = FALSE) is.primitive(p, n = 3, tol = 1e-05)"},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts basic periods to a primitive pair — as.primitive","text":"p Two element vector containing two basic periods n Maximum magnitude matrix entries considered tol Numerical tolerance used determine reality period ratios give.answers Boolean, TRUE meaning return extra     information (unimodular matrix magnitudes primitive     periods) default FALSE meaning return just     primitive periods","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converts basic periods to a primitive pair — as.primitive","text":"Primitive periods unique.  function follows   Chandrasekharan others (, course, Abramowitz Stegun)   demanding real part p1,   imaginary part p2, nonnegative.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts basic periods to a primitive pair — as.primitive","text":"give.answers TRUE, return list components M unimodular matrix used p pair primitive periods mags magnitudes primitive periods","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Converts basic periods to a primitive pair — as.primitive","text":"K. Chandrasekharan 1985. Elliptic functions,  Springer-Verlag","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Converts basic periods to a primitive pair — as.primitive","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Converts basic periods to a primitive pair — as.primitive","text":", “unimodular” includes case determinant minus   one.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/as.primitive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts basic periods to a primitive pair — as.primitive","text":"","code":"as.primitive(c(3+5i,2+3i)) #> [1]  0+1i -1-1i #> attr(,\"class\") #> [1] \"primitive\" as.primitive(c(3+5i,2+3i),n=5) #> [1]  0+1i -1+0i #> attr(,\"class\") #> [1] \"primitive\"  ##Rounding error: is.primitive(c(1,1i)) #> [1] TRUE  ## Try  is.primitive(c(1,1.001i)) #> [1] TRUE"},{"path":"https://robinhankin.github.io/elliptic/reference/ck.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients of Laurent expansion of Weierstrass P function — ck","title":"Coefficients of Laurent expansion of Weierstrass P function — ck","text":"Calculates coefficients Laurent expansion   Weierstrass \\(\\wp\\) function terms invariants","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/ck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients of Laurent expansion of Weierstrass P function — ck","text":"","code":"ck(g, n=20)"},{"path":"https://robinhankin.github.io/elliptic/reference/ck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients of Laurent expansion of Weierstrass P function — ck","text":"g invariants: vector length two g=c(g2,g3) n length series","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/ck.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coefficients of Laurent expansion of Weierstrass P function — ck","text":"Calculates series \\(c_k\\) per equation 18.5.3, p635.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/ck.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coefficients of Laurent expansion of Weierstrass P function — ck","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/ck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients of Laurent expansion of Weierstrass P function — ck","text":"","code":"#Verify 18.5.16, p636:  x <- ck(g=c(0.1+1.1i,4-0.63i)) 14*x[2]*x[3]*(389*x[2]^3+369*x[3]^2)/3187041-x[11] #should be zero #> [1] 2.646978e-23+5.293956e-23i   # Now try a random example by comparing the default (theta function) method # for P(z) with the Laurent expansion:  z <- 0.5-0.3i g <- c(1.1-0.2i, 1+0.4i) series <- ck(15,g=g) 1/z^2+sum(series*(z^2)^(0:14)) - P(z,g=g) #should be zero #> [1] 2.664535e-15-4.440892e-16i"},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":null,"dir":"Reference","previous_headings":"","what":"Solves mx+by=1 for x and y — congruence","title":"Solves mx+by=1 for x and y — congruence","text":"Solves Diophantine equation \\(mx+=1\\) \\(x\\)   \\(y\\).  function named equation 57 Hardy Wright.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solves mx+by=1 for x and y — congruence","text":"","code":"congruence(a, l = 1)"},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solves mx+by=1 for x and y — congruence","text":"Two element vector =c(m,n) l Right hand side default 1","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solves mx+by=1 for x and y — congruence","text":"usual case \\((m,n)=1\\), returns square matrix whose rows c(x,y).  matrix unimodular transformation takes pair basic periods another pair basic periods. \\((m,n)\\neq 1\\) one solution available (example congruence(c(4,6),2)).  case, extra rows added matrix longer square.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Solves mx+by=1 for x and y — congruence","text":"G. H. Hardy  E. M. Wright 1985.  introduction       theory numbers, Oxford University Press (fifth edition)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Solves mx+by=1 for x and y — congruence","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Solves mx+by=1 for x and y — congruence","text":"function generate unimodular matrices   given first row (, assumed function returns   square matrix). start, function returns matrices whose     elements positive, unimodular,     diag() <- -diag(), -    unimodular (originally generated     congruence(), neither derived matrices ). Now first row c(1,23), example, second     row need form c(n,1) n     integer.  thus infinite number unimodular matrices     whose first row c(1,23).  (somewhat)     pathological, consider matrices first row , say,     c(2,5).  second row c(1,3),     c(3,8) c(5,13).  Function congruence()     return first . systematically generate unimodular matrices, use     unimodular(), uses Farey sequences.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/congruence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solves mx+by=1 for x and y — congruence","text":"","code":"M <- congruence(c(4,9)) det(M) #> [1] 1  o <- c(1,1i) g2.fun(o) - g2.fun(o,maxiter=840)  #should be zero #> [1] 0+0i"},{"path":"https://robinhankin.github.io/elliptic/reference/coqueraux.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast, conceptually simple, iterative scheme for Weierstrass P functions — coqueraux","title":"Fast, conceptually simple, iterative scheme for Weierstrass P functions — coqueraux","text":"Fast, conceptually simple, iterative scheme Weierstrass   \\(\\wp\\) functions, following ideas Robert Coqueraux","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/coqueraux.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast, conceptually simple, iterative scheme for Weierstrass P functions — coqueraux","text":"","code":"coqueraux(z, g, N = 5, use.fpp = FALSE, give = FALSE)"},{"path":"https://robinhankin.github.io/elliptic/reference/coqueraux.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast, conceptually simple, iterative scheme for Weierstrass P functions — coqueraux","text":"z Primary complex argument g Invariants; object type parameters supplied,     invariants extracted appropriately N Number iterations use use.fpp Boolean, default FALSE meaning     reduce z fpp.  Setting TRUE reduces     z fpp via parameters():     accurate (see example) slower give Boolean, TRUE meaning return estimate     error, FALSE meaning return just value","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/coqueraux.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fast, conceptually simple, iterative scheme for Weierstrass P functions — coqueraux","text":"R. Coqueraux, 1990.  Iterative method calculation     Weierstrass elliptic function, IMA Journal Numerical Analysis,   volume 10, pp119-128","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/coqueraux.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fast, conceptually simple, iterative scheme for Weierstrass P functions — coqueraux","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/coqueraux.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast, conceptually simple, iterative scheme for Weierstrass P functions — coqueraux","text":"","code":"z <- seq(from=1+1i,to=30-10i,len=55)  p <- P(z,c(0,1))  c.true <- coqueraux(z,c(0,1),use.fpp=TRUE)  c.false <- coqueraux(z,c(0,1),use.fpp=FALSE)  plot(1:55,abs(p-c.false))  points(1:55,abs(p-c.true),pch=16)"},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":null,"dir":"Reference","previous_headings":"","what":"Number theoretic functions — divisor","title":"Number theoretic functions — divisor","text":"Various useful number theoretic functions","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number theoretic functions — divisor","text":"","code":"divisor(n,k=1) primes(n) factorize(n) mobius(n) totient(n) liouville(n)"},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number theoretic functions — divisor","text":"n,k Integers","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number theoretic functions — divisor","text":"Functions primes() factorize() cut--pasted   Bill Venables's con.design package, version 0.0-3.  Function   primes(n) returns vector primes exceeding   n; function factorize(n) returns integer vector   nondecreasing primes whose product n. others multiplicative functions, defined Hardy   Wright: Function divisor(), also written   \\(\\sigma_k(n)\\), divisor function defined   p239.  gives sum \\(k^{\\rm th}\\) powers   divisors n.  Setting \\(k=0\\) corresponds   \\(d(n)\\), gives number divisors n. Function mobius() Moebius function (p234), giving zero   n repeated prime factor, \\((-1)^q\\)   \\(n=p_1p_2\\ldots p_q\\) otherwise. Function totient() Euler's totient function (p52), giving   number integers smaller n relatively prime   . Function liouville() gives Liouville function.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number theoretic functions — divisor","text":"G. H. Hardy E. M. Wright, 1985.  introduction theory numbers (fifth edition).   Oxford University Press.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Number theoretic functions — divisor","text":"divisor function crops g2.fun() g3.fun().   Note function called sigma()   avoid conflicts Weierstrass's \\(\\sigma\\) function (  take priority context).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number theoretic functions — divisor","text":"Robin K. S. Hankin Bill Venables (primes() factorize())","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/divisor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number theoretic functions — divisor","text":"","code":"mobius(1) #> [1] 1 mobius(2) #> [1] -1 divisor(140) #> [1] 336 divisor(140,3) #> [1] 3164112   plot(divisor(1:100,k=1),type=\"s\",xlab=\"n\",ylab=\"divisor(n,1)\")   plot(cumsum(liouville(1:1000)),type=\"l\",main=\"does the function ever exceed zero?\")"},{"path":"https://robinhankin.github.io/elliptic/reference/e16.28.1.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","title":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","text":"Numerical verification formulae 16.28.1 16.28.5 p576","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e16.28.1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","text":"","code":"e16.28.1(z, m, ...) e16.28.2(z, m, ...) e16.28.3(z, m, ...) e16.28.4(z, m, ...) e16.28.5(m, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/e16.28.1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","text":"z Complex number m Parameter \\(m\\) ... Extra arguments passed theta[1-4]()","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e16.28.1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","text":"Returns left hand side minus right hand side formula. formula documented identically zero; nonzero values returned due numerical errors small.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e16.28.1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","text":"M. Abramowitz . . Stegun 1965. Handbook Mathematical       Functions.  New York, Dover.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e16.28.1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e16.28.1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerical verification of equations 16.28.1 to 16.28.5 — e16.28.1","text":"","code":"plot(e16.28.4(z=1:6000,m=0.234))   plot(abs(e16.28.4(z=1:6000,m=0.234+0.1i)))"},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"Numerical checks equations 18.10.9-11, page 650.  Function returns LHS minus RHS.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"","code":"e18.10.9(parameters)"},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"parameters object class “parameters”","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"Returns complex vector length three: \\(e_1\\), \\(e_2\\), \\(e_3\\)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"M. Abramowitz . . Stegun 1965. Handbook Mathematical     Functions.  New York, Dover.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"good check three \\(e\\)'s right order.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e18.10.9.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerical checks of equations 18.10.9-11, page 650 — e18.10.9","text":"","code":"e18.10.9(parameters(g=c(0,1))) #> [1] -2.654255e+01+15.32435i  2.654255e+01+15.32435i  5.329071e-15-30.64869i e18.10.9(parameters(g=c(1,0))) #> [1] -7.105427e-15+0i  0.000000e+00+0i  7.105427e-15+0i"},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate e1, e2, e3 from the invariants — e1e2e3","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"Calculates \\(e_1,e_2,e_3\\) invariants using   either polyroot Cardano's method.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"","code":"e1e2e3(g, use.laurent=TRUE, AnS=is.double(g), Omega=NULL, tol=1e-6) eee.cardano(g)"},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"g Two-element vector g=c(g2,g3) use.laurent Boolean, default TRUE meaning     use P.laurent() determine correct ordering     \\(e\\): \\(\\wp(\\omega_1)\\), \\(\\wp(\\omega_2)\\),     \\(\\wp(\\omega_3)\\).  Setting  FALSE means     return solutions cubic equation directly: much     faster, guaranteed find \\(e_i\\)     right order (roots found according vagaries     polyroot()) AnS Boolean, default TRUE meaning define     \\(\\omega_3\\) per ams-55, FALSE meaning     follow Whittaker Watson, define     \\(\\omega_1\\) \\(\\omega_2\\)     primitive half periods,     \\(\\omega_3=-\\omega_1-\\omega_2\\).      also consistent Chandrasekharan except factor 2. Also note setting AnS TRUE forces     \\(e\\) real Omega pair primitive half periods, known.  supplied,     function uses calculate approximate values three     \\(e\\)s (supplies values calculated polyroot(),     much accurate).  function needs approximate     values determine order \\(e\\)s ,     polyroot() returns roots whichever order polynomial     solver gives tol Real, relative tolerance criterion terminating Laurent     summation","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"Returns three-element vector.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"Function parameters() calls e1e2e3(),     use parameters() determine argument g,     result recursive loop. Just specific: e1e2e3(g=parameters(...)) fail.      pointless anyway, parameters() returns     (inter alia) \\(e_1, e_2, e_3\\). considerable confusion order \\(e_1\\),     \\(e_2\\) \\(e_3\\), essentially due Abramowitz     Stegun's definition half periods inconsistent     Chandrasekharan's, Mathematica's.  possible     reconcile S's notation theta functions     Chandrasekharan's definition primitive pair.  Thus,     convention adopted rather strange-seeming choice     \\(e_1=\\wp(\\omega_1/2)\\),     \\(e_2=\\wp(\\omega_3/2)\\),     \\(e_3=\\wp(\\omega_2/2)\\).  advantage     making equation 18.10.5 (p650, ams55), equation     09.13.27.0011.01, return three identical values. scheme rescue 18.10.5 define     \\((\\omega_1,\\omega_3)\\) primitive pair,     require     \\(\\omega_2=-\\omega_1-\\omega_3\\).      method adopted Mathematica; inconsistent     ams55 solution used package elliptic.  However,     scheme suffers     disadvantage independent elements Omega     supplied c(omega1,NA,omega3),     inimical precepts R. One can realize practice     considering package calls     “\\(\\omega_2\\)” really     \\(\\omega_3\\), package calls     “\\(\\omega_1+\\omega_2\\)”     really \\(\\omega_2\\).  Making function     half.periods() return three element vector names     omega1, omega3, omega2 might work     levels, indeed might correct solution user     somewhere; confusing.  confusion     dog weary steps ever .","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"Mathematica","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/e1e2e3.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate e1, e2, e3 from the invariants — e1e2e3","text":"","code":"sum(e1e2e3(g=c(1,2))) #> [1] 0+0i"},{"path":"https://robinhankin.github.io/elliptic/reference/elliptic-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Weierstrass and Jacobi Elliptic Functions — elliptic-package","title":"Weierstrass and Jacobi Elliptic Functions — elliptic-package","text":"suite elliptic related functions including Weierstrass  Jacobi forms.  Also includes various tools manipulating  visualizing complex functions.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/elliptic-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Weierstrass and Jacobi Elliptic Functions — elliptic-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time. primary function package elliptic P(): calculates Weierstrass \\(\\wp\\) function, may take named arguments specify either invariants g half periods Omega.  derivative given function Pdash Weierstrass sigma zeta functions given functions sigma() zeta() respectively; documented ?P.  Jacobi forms documented ?sn modular forms ?J. Notation follows Abramowitz Stegun (1965) possible, although real invariants considered; ?e1e2e3 ?parameters give detailed discussion.  Various equations AMS-55 implemented (fun); functions named equation numbers AMS-55; references work unless otherwise indicated. package uses Jacobi's theta functions (?theta ?theta.neville) possible: converge quickly. Various number-theoretic functions required (eg) converting period pair primitive form (?.primitive) implemented; see ?divisor list. package also provides tools numerical verification complex analysis contour integration (?myintegrate) Newton-Raphson iteration complex functions (?newton_raphson). Complex functions may visualized using view(); customizable extensive set built-colourmaps.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/elliptic-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Weierstrass and Jacobi Elliptic Functions — elliptic-package","text":"Robin K. S. Hankin [aut, cre] (<https://orcid.org/0000-0001-5982-0415>) Maintainer: Robin K. S. Hankin <hankin.robin@gmail.com>","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/elliptic-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weierstrass and Jacobi Elliptic Functions — elliptic-package","text":"","code":"## Example 8, p666, RHS:  P(z=0.07 + 0.1i, g=c(10,2))  #> [1] -22.9745-63.05323i       ## Now a nice little plot of the zeta function:  x <- seq(from=-4,to=4,len=100)  z <- outer(x,1i*x,\"+\")  par(pty=\"s\")  view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=3,scheme=1)   view(x,x,P(z*3,params=equianharmonic()),real=FALSE)        ## Some number theory:  mobius(1:10) #>  [1]  1 -1 -1  0 -1  1 -1  0  0  1  plot(divisor(1:300,k=1),type=\"s\",xlab=\"n\",ylab=\"divisor(n,1)\")       ## Primitive periods:  as.primitive(c(3+4.01i , 7+10i)) #> [1]  1+1.98i -2-2.03i #> attr(,\"class\") #> [1] \"primitive\"  as.primitive(c(3+4.01i , 7+10i),n=10)   # Note difference #> [1] 1+0.05i 0+1.93i #> attr(,\"class\") #> [1] \"primitive\"      ## Now some contour integration:  f <- function(z){1/z}  u <- function(x){exp(2i*pi*x)}  udash <- function(x){2i*pi*exp(2i*pi*x)}  integrate.contour(f,u,udash) - 2*pi*1i #> [1] -3.561641e-17-8.881784e-16i    x <- seq(from=-10,to=10,len=200)  z <- outer(x,1i*x,\"+\")  view(x,x,P(z,params=lemniscatic()),real=FALSE)   view(x,x,P(z,params=pseudolemniscatic()),real=FALSE)   view(x,x,P(z,params=equianharmonic()),real=FALSE)"},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":null,"dir":"Reference","previous_headings":"","what":"Special cases of the Weierstrass elliptic function — equianharmonic","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"Gives parameters equianharmonic case, lemniscatic case, pseudolemniscatic case.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"","code":"equianharmonic(...) lemniscatic(...) pseudolemniscatic(...)"},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"... Ignored","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"functions return values section 18.13, p652; 18.14, p658;   18.15, p662.  use elementary functions (gamma   function) , accurate faster calling   parameters(g=c(1,0)) directly. Note values half periods correspond general   case complex g2 g3 simple linear   combinations given AnS. One can use parameters(\"equianharmonic\") et seq instead.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"Returns list elements parameters().","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"M. Abramowitz . . Stegun 1965. Handbook Mathematical       Functions.  New York, Dover.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/equianharmonic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Special cases of the Weierstrass elliptic function — equianharmonic","text":"","code":"P(z=0.1+0.1212i,params=equianharmonic()) #> [1] -7.693069-39.76585i   x <- seq(from=-10,to=10,len=200) z <- outer(x,1i*x,\"+\") view(x,x,P(z,params=lemniscatic()),real=FALSE)  view(x,x,P(z,params=pseudolemniscatic()),real=FALSE)  view(x,x,P(z,params=equianharmonic()),real=FALSE)"},{"path":"https://robinhankin.github.io/elliptic/reference/eta.html","id":null,"dir":"Reference","previous_headings":"","what":"Dedekind's eta function — eta","title":"Dedekind's eta function — eta","text":"Dedekind's \\(\\eta\\) function","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/eta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dedekind's eta function — eta","text":"","code":"eta(z, ...) eta.series(z, maxiter=300)"},{"path":"https://robinhankin.github.io/elliptic/reference/eta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dedekind's eta function — eta","text":"z Complex argument ... function eta(), extra arguments sent     theta3() maxiter function eta.series(), maximum value     iteration","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/eta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dedekind's eta function — eta","text":"Function eta() uses Euler's formula, viz   $$\\eta(z)=e^{\\pi       iz/12}\\theta_3\\left(\\frac{1}{2}+\\frac{z}{2},3z\\right)$$ Function eta.series() present validation (interest)   ; uses infinite product formula:   $$\\eta(z)=     e^{\\pi iz/12}\\prod_{n=1}^\\infty\\left(1-e^{2\\pi inz}\\right)$$","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/eta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dedekind's eta function — eta","text":"K. Chandrasekharan 1985. Elliptic functions,  Springer-Verlag.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/eta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Dedekind's eta function — eta","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/eta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dedekind's eta function — eta","text":"","code":"z <- seq(from=1+1i,to=10+0.06i,len=999)  plot(eta(z))   max(abs(eta(z)-eta.series(z))) #> [1] 1.445008e-14"},{"path":"https://robinhankin.github.io/elliptic/reference/farey.html","id":null,"dir":"Reference","previous_headings":"","what":"Farey sequences — farey","title":"Farey sequences — farey","text":"Returns Farey sequence order \\(n\\)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/farey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Farey sequences — farey","text":"","code":"farey(n, print=FALSE, give.series = FALSE)"},{"path":"https://robinhankin.github.io/elliptic/reference/farey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Farey sequences — farey","text":"n Order Farey sequence print Boolean, TRUE meaning print text     version Farey sequence human-readable form.  Default value     FALSE means print anything give.series Boolean, TRUE meaning return     series explicitly, default FALSE meaning return 3     dimensional array detailed ","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/farey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Farey sequences — farey","text":"give.series takes default value FALSE, return   matrix dimension c(2,u) u   (complicated) function n.  v <- [,],   v[1]/v[2] \\(^{\\mathrm{th}}\\) term Farey   sequence.  Note det([(n):(n+1),])== -1 give.series TRUE, return matrix   size c(4,u-1).  v <- [,], v[1]/v[2]   v[3]/v[4] successive pairs Farey sequence.  Note   det(matrix([,],2,2))== -1","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/farey.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Farey sequences — farey","text":"G. H. Hardy  E. M. Wright 1985.  introduction       theory numbers, Oxford University Press (fifth edition)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/farey.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Farey sequences — farey","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/farey.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Farey sequences — farey","text":"","code":"farey(3) #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    1    2 #> [2,]    1    3    2    3 #> [3,]    1    1    2    1 #> [4,]    3    2    3    1"},{"path":"https://robinhankin.github.io/elliptic/reference/fpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Fundamental period parallelogram — fpp","title":"Fundamental period parallelogram — fpp","text":"Reduce \\(z=x+iy\\) congruent value within   fundamental period parallelogram (FPP).  Function mn() gives   (real, possibly noninteger) \\(m\\) \\(n\\)   \\(z=m\\cdot p_1+n\\cdot p_2\\).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/fpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fundamental period parallelogram — fpp","text":"","code":"fpp(z, p, give=FALSE) mn(z, p)"},{"path":"https://robinhankin.github.io/elliptic/reference/fpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fundamental period parallelogram — fpp","text":"z Primary complex argument p Vector length two first element first period     second element second period.  Note \\(p\\)     period, \\(p_1=2\\omega_1\\), \\(\\omega_1\\)     half period give Boolean,  TRUE meaning return M N,     default FALSE meaning return just congruent values","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/fpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fundamental period parallelogram — fpp","text":"Function fpp() fully vectorized. Use function mn() determine “coordinates”   point. Use floor(mn(z,p)) %*% p  give  complex value   (unique) point period parallelogram z   congruent origin.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/fpp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fundamental period parallelogram — fpp","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/fpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fundamental period parallelogram — fpp","text":"","code":"p <- c(1.01+1.123i, 1.1+1.43i) mn(z=1:10,p) %*% p  ## should be close to 1:10 #>                   [,1] #>  [1,]  1-1.277872e-16i #>  [2,]  2-2.555744e-16i #>  [3,]  3+4.057530e-15i #>  [4,]  4-5.111488e-16i #>  [5,]  5-6.607495e-15i #>  [6,]  6+8.115061e-15i #>  [7,]  7+3.546382e-15i #>  [8,]  8-1.022298e-15i #>  [9,]  9-5.590977e-15i #> [10,] 10-1.321499e-14i   #Now specify some periods:  p2 <- c(1+1i,1-1i)   #Define a sequence of complex numbers that zooms off to infinity:  u <- seq(from=0,by=pi+1i*exp(1),len=2007)   #and plot the sequence, modulo the periods:  plot(fpp(z=u,p=p2))   #and check that the resulting points are within the qpp: polygon(c(-1,0,1,0),c(0,1,0,-1))"},{"path":"https://robinhankin.github.io/elliptic/reference/g.fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the invariants g2 and g3 — g.fun","title":"Calculates the invariants g2 and g3 — g.fun","text":"Calculates invariants g2 g3 using number methods","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/g.fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the invariants g2 and g3 — g.fun","text":"","code":"g.fun(b, ...) g2.fun(b, use.first=TRUE, ...) g3.fun(b, use.first=TRUE, ...) g2.fun.lambert(b, nmax=50, tol=1e-10, strict=TRUE) g3.fun.lambert(b, nmax=50, tol=1e-10, strict=TRUE) g2.fun.direct(b, nmax=50, tol=1e-10) g3.fun.direct(b, nmax=50, tol=1e-10) g2.fun.fixed(b, nmax=50, tol=1e-10, give=FALSE) g3.fun.fixed(b, nmax=50, tol=1e-10, give=FALSE) g2.fun.vectorized(b, nmax=50, tol=1e-10, give=FALSE) g3.fun.vectorized(b, nmax=50, tol=1e-10, give=FALSE)"},{"path":"https://robinhankin.github.io/elliptic/reference/g.fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the invariants g2 and g3 — g.fun","text":"b Half periods.  NB: arguments   half periods per AMS55!   functions, argument b interpreted per   p1.tau() nmax Maximum number terms sum.  See details section   discussion tol Numerical tolerance stopping: summation stops adding   additional term makes less strict Boolean, default (taken) TRUE meaning   stop() convergence achieved nmax terms.   Setting FALSE returns partial sum warning. give Boolean, default (taken) TRUE meaning   return partial sums.  See examples section example   argument use ... functions g.fun(), g2.fun()   g3.fun(), extra arguments passed theta1() friends use.first function g2.fun() g3.fun(),   Boolean default TRUE meaning use Wolfram's first formula   (remember cite ) FALSE meaning use second","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/g.fun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates the invariants g2 and g3 — g.fun","text":"Functions g2.fun() g3.fun() use theta functions   converge quickly.  functions best   circumstances.  theta functions include loop continues add   terms partial sum unaltered addition   next term.  Note summation continues   elements argument properly summed, performance   limited single worst-case element. following functions provided interest , although   remote possibility weird circumstances may exist   faster theta function approach. Functions g2.fun.divisor() g3.fun.divisor() use   Chandrasekharan's formula page 83.  generally slower   theta function approach Functions g2.fun.lambert() g3.fun.lambert() use   Lambert series accelerate Chandrasekharan's formula.  general,   little better divisor form. Functions g2.fun.fixed() g2.fun.fixed() also use   Lambert series.  functions vectorized sense   function body uses vector operations.  functions   take vector argument.  called “fixed”   number terms used fixed advance (unlike g2.fun()   g3.fun()). Functions g2.fun.vectorized() g3.fun.vectorized()   also use Lambert series.  fully vectorized take   vector periods period ratios, unlike previous two   functions.  However, can lead loss precision   cases (specifically periods give rise widely varying   values g2 g3). Functions g2.fun.direct() g3.fun.direct() use   direct summation.  functions absurdly slow.  general,   Lambert series functions converge much faster;   “default” functions g2.fun() g3.fun(),   use theta functions, converge faster still.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/g.fun.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculates the invariants g2 and g3 — g.fun","text":"Mathematica website","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/g.fun.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculates the invariants g2 and g3 — g.fun","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/g.fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the invariants g2 and g3 — g.fun","text":"","code":"g.fun(half.periods(g=c(8,4+1i)))  ## should be c(8,4+1i) #>              g2              g3  #> 8-1.887379e-15i 4+1.000000e+00i   ## Example 4, p664, LHS: omega <- c(10,11i) (g2 <- g2.fun(omega)) #> [1] 0.001007577+0i (g3 <- g3.fun(omega)) #> [1] 2.14201e-06+0i e1e2e3(Re(c(g2,g3))) #>           e1           e2           e3  #>  0.016843041 -0.002166258 -0.014676784   ## Example 4, p664, RHS: omega2 <- 10 omega2dash <- 11i omega1 <- (omega2-omega2dash)/2   ## From figure 18.1, p630 (g2 <- g2.fun(c(omega1,omega2))) #> [1] -0.003748749+7.589415e-19i (g3 <- g3.fun(c(omega1,omega2))) #> [1] 1.656681e-05-8.470329e-22i e1e2e3(Re(c(g2,g3))) #>                       e1                       e2                       e3  #> -0.002166258+0.03084259i  0.004332515+0.00000000i -0.002166258-0.03084259i"},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates half periods in terms of e — half.periods","title":"Calculates half periods in terms of e — half.periods","text":"Calculates half periods terms \\(e\\)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates half periods in terms of e — half.periods","text":"","code":"half.periods(ignore=NULL, e=NULL, g=NULL, primitive)"},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates half periods in terms of e — half.periods","text":"e e g g ignore Formal argument present ensure e     g named (ignored) primitive Boolean, default TRUE meaning return     primitive periods FALSE return direct result     Legendre's iterative scheme","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates half periods in terms of e — half.periods","text":"Parameter e=c(e1,e2,e3) values Weierstrass   \\(\\wp\\) function half periods:   $$e_1=\\wp(\\omega_1)\\qquad e_2=\\wp(\\omega_2)\\qquad e_3=   \\wp(\\omega_3)$$   $$\\omega_1+\\omega_2+\\omega_3=0.$$ Also, \\(e\\) given roots cubic   equation \\(x^3-g_2x-g_3=0\\), problem   finding root corresponds three elements   \\(e\\).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates half periods in terms of e — half.periods","text":"Returns pair primitive half periods","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculates half periods in terms of e — half.periods","text":"M. Abramowitz . . Stegun 1965. Handbook Mathematical       Functions.  New York, Dover.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculates half periods in terms of e — half.periods","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculates half periods in terms of e — half.periods","text":"Function parameters() uses function half.periods()   internally, use parameters()   determine e.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/half.periods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates half periods in terms of e — half.periods","text":"","code":"half.periods(g=c(8,4))                ## Example 6, p665, LHS #> [1] 1.009453+0.000000i 0.000000+1.484412i #> attr(,\"class\") #> [1] \"primitive\"  u <- half.periods(g=c(-10,2)) massage(c(u[1]-u[2] , u[1]+u[2]))     ## Example 6, p665, RHS #> [1] 0.000000-1.52561i 1.402395+0.00000i  half.periods(g=c(10,2))               ## Example 7, p665, LHS #> [1] 1.003847+0.00000i 0.000000+1.09797i #> attr(,\"class\") #> [1] \"primitive\"  u <- half.periods(g=c(7,6)) massage(c(u[1],2*u[2]+u[1]))          ## Example 7, p665, RHS #> [1] 0.9957998+0.000000i 0.0000000+2.332418i   half.periods(g=c(1,1i, 1.1+1.4i)) #> [1] 0.3004954-1.4486012i 1.4486012-0.3004954i #> attr(,\"class\") #> [1] \"primitive\" half.periods(e=c(1,1i, 2, 1.1+1.4i)) #> [1] 0.3561185-1.1207477i 1.2654855+0.1622369i #> attr(,\"class\") #> [1] \"primitive\"   g.fun(half.periods(g=c(8,4)))         ##  should be c(8,4) #>   g2   g3  #> 8+0i 4+0i"},{"path":"https://robinhankin.github.io/elliptic/reference/latplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a lattice of periods on the complex plane — latplot","title":"Plots a lattice of periods on the complex plane — latplot","text":"Given pair basic periods, plots lattice periods complex plane","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/latplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a lattice of periods on the complex plane — latplot","text":"","code":"latplot(p, n=10, do.lines=TRUE, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/latplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a lattice of periods on the complex plane — latplot","text":"p Vector length two first element first period     second element second period.  Note     \\(p_1=2\\omega_1\\) n Size lattice .lines Boolean default TRUE meaning show     boundaries adjacent period parallelograms ... Extra arguments passed     plot().  See examples section working use","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/latplot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plots a lattice of periods on the complex plane — latplot","text":"K. Chandrasekharan 1985. Elliptic functions,   Springer-Verlag.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/latplot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plots a lattice of periods on the complex plane — latplot","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/latplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a lattice of periods on the complex plane — latplot","text":"","code":"p1 <- c(1,1i) p2 <- c(2+3i,5+7i) latplot(p1)  latplot(p2,xlim=c(-4,4),ylim=c(-4,4),n=40)"},{"path":"https://robinhankin.github.io/elliptic/reference/lattice.html","id":null,"dir":"Reference","previous_headings":"","what":"Lattice of complex numbers — lattice","title":"Lattice of complex numbers — lattice","text":"Returns lattice numbers generated  given complex basis.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/lattice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lattice of complex numbers — lattice","text":"","code":"lattice(p,n)"},{"path":"https://robinhankin.github.io/elliptic/reference/lattice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lattice of complex numbers — lattice","text":"p Complex vector length two giving basis lattice n size lattice","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/lattice.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lattice of complex numbers — lattice","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/lattice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lattice of complex numbers — lattice","text":"","code":"lattice(c(1+10i,100+1000i),n=2) #>            [,1]       [,2]   [,3]      [,4]      [,5] #> [1,] -202-2020i -102-1020i -2-20i  98+ 980i 198+1980i #> [2,] -201-2010i -101-1010i -1-10i  99+ 990i 199+1990i #> [3,] -200-2000i -100-1000i  0+ 0i 100+1000i 200+2000i #> [4,] -199-1990i  -99- 990i  1+10i 101+1010i 201+2010i #> [5,] -198-1980i  -98- 980i  2+20i 102+1020i 202+2020i plot(lattice(c(1+1i,1.1+1.4i),5))"},{"path":"https://robinhankin.github.io/elliptic/reference/limit.html","id":null,"dir":"Reference","previous_headings":"","what":"Limit the magnitude of elements of a vector — limit","title":"Limit the magnitude of elements of a vector — limit","text":"Deals appropriately objects large elements","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/limit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Limit the magnitude of elements of a vector — limit","text":"","code":"limit(x, upper=quantile(Re(x),0.99,na.rm=TRUE),          lower=quantile(Re(x),0.01,na.rm=TRUE),          na = FALSE)"},{"path":"https://robinhankin.github.io/elliptic/reference/limit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Limit the magnitude of elements of a vector — limit","text":"x Vector real complex values upper Upper limit lower Lower limit na Boolean, default FALSE meaning “clip”     x (real) setting elements x x>high     high; TRUE, set elements NA.     x complex, argument ignored","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/limit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Limit the magnitude of elements of a vector — limit","text":"x complex, low ignored function returns   x, executing x[abs(x)>high] <- NA.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/limit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Limit the magnitude of elements of a vector — limit","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/limit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Limit the magnitude of elements of a vector — limit","text":"","code":"x <- c(rep(1,5),300, -200) limit(x,100) #> [1]    1.00    1.00    1.00    1.00    1.00  100.00 -187.94 limit(x,upper=200,lower= -400) #> [1]    1    1    1    1    1  200 -200 limit(x,upper=200,lower= -400,na=TRUE) #> [1]    1    1    1    1    1   NA -200"},{"path":"https://robinhankin.github.io/elliptic/reference/massage.html","id":null,"dir":"Reference","previous_headings":"","what":"Massages numbers near the real line to be real — massage","title":"Massages numbers near the real line to be real — massage","text":"Returns Real part numbers near real line","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/massage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Massages numbers near the real line to be real — massage","text":"","code":"massage(z, tol = 1e-10)"},{"path":"https://robinhankin.github.io/elliptic/reference/massage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Massages numbers near the real line to be real — massage","text":"z vector complex numbers massaged tol Tolerance","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/massage.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Massages numbers near the real line to be real — massage","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/massage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Massages numbers near the real line to be real — massage","text":"","code":"massage(1+1i) #> [1] 1+1i massage(1+1e-11i) #> [1] 1  massage(c(1,1+1e-11i,1+10i)) #> [1] 1+ 0i 1+ 0i 1+10i"},{"path":"https://robinhankin.github.io/elliptic/reference/misc.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate real or imaginary components of an object — misc","title":"Manipulate real or imaginary components of an object — misc","text":"Manipulate real imaginary components object","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/misc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate real or imaginary components of an object — misc","text":"","code":"Im(x) <- value Re(x) <- value"},{"path":"https://robinhankin.github.io/elliptic/reference/misc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manipulate real or imaginary components of an object — misc","text":"x Complex-valued object value Real-valued object","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/misc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Manipulate real or imaginary components of an object — misc","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/misc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manipulate real or imaginary components of an object — misc","text":"","code":"x <- 1:10 Im(x) <- 1  x <- 1:5 Im(x) <- 1/x"},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":null,"dir":"Reference","previous_headings":"","what":"Moebius transformations — mob","title":"Moebius transformations — mob","text":"Moebius transformations","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moebius transformations — mob","text":"","code":"mob(M, x) M %mob% x"},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moebius transformations — mob","text":"M 2--2 matrix integers x vector values transformed","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moebius transformations — mob","text":"Returns value attributes x.  Elementwise, $$M=\\left(\\begin{array}{cc}&b\\\\c&d\\end{array}\\right)$$ mob(M,x) \\(\\frac{ax+b}{cx+d}\\).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Moebius transformations — mob","text":"Wikipedia contributors, \"Mobius transformation,\" Wikipedia, Free   Encyclopedia (accessed February 13, 2011).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Moebius transformations — mob","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Moebius transformations — mob","text":"function check M integer   elements, determinant unity.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/mob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moebius transformations — mob","text":"","code":"M <- matrix(c(11,6,9,5),2,2) x <- seq(from=1+1i,to=10-2i,len=6)  M %mob% x #> [1] 1.821656+0.0063694268i 1.825780+0.0008316008i 1.828228-0.0001879346i #> [4] 1.829539-0.0004195951i 1.830330-0.0004653946i 1.830854-0.0004577707i plot(mob(M,x))"},{"path":"https://robinhankin.github.io/elliptic/reference/myintegrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Complex integration — myintegrate","title":"Complex integration — myintegrate","text":"Integration complex valued functions along real axis   (myintegrate()), along arbitrary paths   (integrate.contour()), following arbitrary straight line   segments (integrate.segments()).  Also, evaluation function   point using residue theorem (residue()).   vignette   (“residuetheorem”) provided package.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/myintegrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complex integration — myintegrate","text":"","code":"myintegrate(f, lower,upper, ...) integrate.contour(f,u,udash, ...) integrate.segments(f,points, close=TRUE, ...) residue(f, z0, r, O=z0, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/myintegrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complex integration — myintegrate","text":"f function, possibly complex valued lower,upper Lower upper limits integration myintegrate();     real numbers (complex values, use integrate.contour()     integrate.segments()) u Function mapping \\([0,1]\\) contour.      closed contour, require \\(u(0)=u(1)\\) udash Derivative u points function integrate.segments(), vector complex     numbers.  Integration taken straight segments joining     consecutive elements points close function integrate.segments(), Boolean     variable default TRUE meaning integrate along segment     points[n] points[1] addition internal     segments r,O,z0 function residue() returns f(z0)     integrating \\(f(z)/(z-z0)\\) around circle radius r     center O ... Extra arguments passed integrate()","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/myintegrate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Complex integration — myintegrate","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/myintegrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Complex integration — myintegrate","text":"","code":"f1 <- function(z){sin(exp(z))} f2 <- function(z,p){p/z}  myintegrate(f1,2,3)  # that is, along the real axis #> [1] 0.0551893+0i   integrate.segments(f1,c(1,1i,-1,-1i),close=TRUE)   # should be zero #> [1] 0+0i  # (following should be pi*2i; note secondary argument): integrate.segments(f2,points=c(1,1i,-1,-1i),close=TRUE,p=1) #> [1] -2.596731e-18+6.283185i    # To integrate round the unit circle, we need the contour and its # derivative:   u <- function(x){exp(pi*2i*x)}  udash <- function(x){pi*2i*exp(pi*2i*x)}  # Some elementary functions, for practice:  # (following should be 2i*pi; note secondary argument 'p'): integrate.contour(function(z,p){p/z},u,udash,p=1)       #> [1] -3.561641e-17+6.283185i integrate.contour(function(z){log(z)},u,udash)         # should be -2i*pi #> [1] -8.881784e-16-6.283185i integrate.contour(function(z){sin(z)+1/z^2},u,udash)   # should be zero #> [1] 1.079679e-16-8.298917e-15i    # residue() is a convenience wrapper integrating f(z)/(z-z0) along a # circular contour:  residue(function(z){1/z},2,r=0.1)  # should be 1/2=0.5 #> [1] 0.5-7.160673e-17i    # Now, some elliptic functions: g <- c(3,2+4i) Zeta <- function(z){zeta(z,g)} Sigma <- function(z){sigma(z,g)} WeierstrassP <- function(z){P(z,g)}  jj <- integrate.contour(Zeta,u,udash)  abs(jj-2*pi*1i)                              # zero to numerical precision #> [1] 9.302781e-16 abs(integrate.contour(Sigma,u,udash))        # zero to numerical precision #> [1] 2.576717e-12 abs(integrate.contour(WeierstrassP,u,udash)) # zero to numerical precision #> [1] 2.482534e-16   # Now integrate f(x) = exp(1i*x)/(1+x^2) from -Inf to +Inf along the # real axis, using the Residue Theorem.  This tells us that integral of # f(z) along any closed path is equal to pi*2i times the sum of the # residues inside it.  Take a semicircular path P from -R to +R along # the real axis, then following a semicircle in the upper half plane, of # radius R to close the loop.  Now consider large R.  Then P encloses a # pole at +1i [there is one at -1i also, but this is outside P, so # irrelevant here] at which the residue is -1i/2e.  Thus the integral of # f(z) = 2i*pi*(-1i/2e) = pi/e along P; the contribution from the # semicircle tends to zero as R tends to infinity; thus the integral # along the real axis is the whole path integral, or pi/e.  # We can now reproduce this result analytically.  First, choose an R: R <- 400  # now define P.  First, the semicircle, u1: u1     <- function(x){R*exp(pi*1i*x)} u1dash <- function(x){R*pi*1i*exp(pi*1i*x)}  # and now the straight part along the real axis, u2: u2     <- function(x){R*(2*x-1)} u2dash <- function(x){R*2}  # Better define the function: f <- function(z){exp(1i*z)/(1+z^2)}  # OK, now carry out the path integral.  I'll do it explicitly, but note # that the contribution from the first integral should be small:  answer.approximate <-     integrate.contour(f,u1,u1dash) +     integrate.contour(f,u2,u2dash)   # And compare with the analytical value: answer.exact <- pi/exp(1) abs(answer.approximate - answer.exact) #> [1] 6.244969e-07   # Now try the same thing but integrating over a triangle, using # integrate.segments().  Use a path P' with base from -R to +R along the # real axis, closed by two straight segments, one from +R to 1i*R, the # other from 1i*R to -R:  abs(integrate.segments(f,c(-R,R,1i*R))- answer.exact) #> [1] 5.157772e-07   # Observe how much better one can do by integrating over a big square # instead:  abs(integrate.segments(f,c(-R,R,R+1i*R, -R+1i*R))- answer.exact) #> [1] 2.319341e-08   # Now in the interests of search engine findability, here is an # application of Cauchy's integral formula, or Cauchy's formula.  I will # use it to find sin(0.8):  u     <- function(x){exp(pi*2i*x)} udash <- function(x){pi*2i*exp(pi*2i*x)}  g <- function(z){sin(z)/(z-0.8)}  a <- 1/(2i*pi)*integrate.contour(g,u,udash)   abs(a-sin(0.8)) #> [1] 3.752575e-14"},{"path":"https://robinhankin.github.io/elliptic/reference/near.match.html","id":null,"dir":"Reference","previous_headings":"","what":"Are two vectors close to one another? — near.match","title":"Are two vectors close to one another? — near.match","text":"Returns TRUE element x y   “near” one another","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/near.match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are two vectors close to one another? — near.match","text":"","code":"near.match(x, y, tol=NULL)"},{"path":"https://robinhankin.github.io/elliptic/reference/near.match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are two vectors close to one another? — near.match","text":"x First object y Second object tol Relative tolerance default NULL meaning use machine     precision","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/near.match.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Are two vectors close to one another? — near.match","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/near.match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are two vectors close to one another? — near.match","text":"","code":"x <- rep(1,6) near.match(x, x+rnorm(6)/1e10) #> [1] FALSE"},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":null,"dir":"Reference","previous_headings":"","what":"Newton Raphson iteration to find roots of equations — newton_raphson","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"Newton-Raphson iteration find roots equations emphasis complex functions","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"","code":"newton_raphson(initial, f, fdash, maxiter, give=TRUE, tol = .Machine$double.eps)"},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"initial Starting guess f Function \\(f(z)=0\\) solved     \\(z\\) fdash Derivative function (note: Cauchy-Riemann conditions     assumed) maxiter Maximum number iterations attempted give Boolean, default TRUE meaning give     output based uniroot() FALSE meaning     return estimated root tol Tolerance: iteration stops \\(|f(z)|<tol\\)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"Bog-standard implementation Newton-Raphson algorithm","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"give FALSE,   returns \\(z\\) \\(|f(z)|<tol\\); TRUE, returns list   elements root (estimated root), f.root (  function evaluated estimated root; small modulus),   iter, number iterations required.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"Previous versions function used misspelling “Rapheson”.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/newton_raphson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Newton Raphson iteration to find roots of equations — newton_raphson","text":"","code":"# Find the two square roots of 2+i: f <- function(z){z^2-(2+1i)} fdash <- function(z){2*z} newton_raphson( 1.4+0.3i,f,fdash,maxiter=10) #> $root #> [1] 1.455347+0.3435607i #>  #> $f.root #> [1] 0+0i #>  #> $iter #> [1] 5 #>  newton_raphson(-1.4-0.3i,f,fdash,maxiter=10) #> $root #> [1] -1.455347-0.3435607i #>  #> $f.root #> [1] 0+0i #>  #> $iter #> [1] 5 #>   # Now find the three cube roots of unity: g <- function(z){z^3-1} gdash <- function(z){3*z^2} newton_raphson(-0.5+1i,g,gdash,maxiter=10) #> $root #> [1] -0.5+0.8660254i #>  #> $f.root #> [1] 2.220446e-16-1.110223e-16i #>  #> $iter #> [1] 6 #>  newton_raphson(-0.5-1i,g,gdash,maxiter=10) #> $root #> [1] -0.5-0.8660254i #>  #> $f.root #> [1] 2.220446e-16+1.110223e-16i #>  #> $iter #> [1] 6 #>  newton_raphson(+0.5+0i,g,gdash,maxiter=10) #> $root #> [1] 1+0i #>  #> $f.root #> [1] 0+0i #>  #> $iter #> [1] 7 #>"},{"path":"https://robinhankin.github.io/elliptic/reference/nome.html","id":null,"dir":"Reference","previous_headings":"","what":"Nome in terms of m or k — nome","title":"Nome in terms of m or k — nome","text":"Calculates nome terms either \\(m\\) (nome())   \\(k\\) (nome.k()).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/nome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nome in terms of m or k — nome","text":"","code":"nome(m) nome.k(k)"},{"path":"https://robinhankin.github.io/elliptic/reference/nome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nome in terms of m or k — nome","text":"m Real parameter k Real parameter \\(k=m^2\\)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/nome.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Nome in terms of m or k — nome","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/nome.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Nome in terms of m or k — nome","text":"nome defined \\(e^{-\\pi K'/K}\\),   \\(K\\) \\(iK'\\) quarter periods (see page 576   AMS-55).  calculated using function K.fun().","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/nome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nome in terms of m or k — nome","text":"","code":"nome(0.09)  # AMS-55 give 0.00589414 in example 7 on page 581 #> [1] 0.005894144"},{"path":"https://robinhankin.github.io/elliptic/reference/p1.tau.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","title":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","text":"Takes vectors   interprets appropriately input g2.fun()   g3.fun().  really intended end user.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/p1.tau.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","text":"","code":"p1.tau(b)"},{"path":"https://robinhankin.github.io/elliptic/reference/p1.tau.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","text":"b Vector periods","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/p1.tau.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","text":"b length two, interpret elements   \\(\\omega_1\\) \\(\\omega_2\\) respectively. two-column matrix, interpret columns   \\(\\omega_1\\) \\(\\omega_2\\) respectively. Otherwise, interpret vector   \\(\\tau=\\omega_1/\\omega_2\\).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/p1.tau.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","text":"Returns two-component list: p1 First period tau Period ratio","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/p1.tau.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/p1.tau.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the Right Thing (tm) when calling g2.fun() and g3.fun() — p1.tau","text":"","code":"p1.tau(c(1+1i,1.1+23.123i)) #> $p1 #> [1] 1+1i #>  #> $tau #> [1] 12.1115+11.0115i #>"},{"path":"https://robinhankin.github.io/elliptic/reference/parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameters for Weierstrass's P function — parameters","title":"Parameters for Weierstrass's P function — parameters","text":"Calculates invariants \\(g_2\\) \\(g_3\\),   e-values \\(e_1,e_2,e_3\\), half periods   \\(\\omega_1,\\omega_2\\), one .","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameters for Weierstrass's P function — parameters","text":"","code":"parameters(Omega=NULL, g=NULL, description=NULL)"},{"path":"https://robinhankin.github.io/elliptic/reference/parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameters for Weierstrass's P function — parameters","text":"Omega Vector length two, containing half       periods \\((\\omega_1,\\omega_2)\\) g Vector length two:     \\((g_2,g_3)\\) description string containing “equianharmonic”,     “lemniscatic”, “pseudolemniscatic”, specify one     S's special cases","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameters for Weierstrass's P function — parameters","text":"Returns list following items:  Omega complex vector length 2 giving fundamental half     periods \\(\\omega_1\\) \\(\\omega_2\\).  Notation     follows Chandrasekharan: half period     \\(\\omega_1\\) 0.5 times (nontrivial) period minimal     modulus, \\(\\omega_2\\) 0.5 times period smallest     modulus property \\(\\omega_2/\\omega_1\\)     real. relevant periods made unique requirement     \\(\\mathrm{Re}(\\omega_1)>0\\),     \\(\\mathrm{Im}(\\omega_2)>0\\); note     often results sign changes considering cases boundaries     (real \\(g_2\\) \\(g_3\\)). Note Different definitions exist \\(\\omega_3\\)!     S use \\(\\omega_3=\\omega_2-\\omega_1\\),     Whittaker Watson (eg, page 443), Mathematica,     \\(\\omega_1+\\omega_2+\\omega_3=0\\) q nome.  ,       \\(q=e^{\\pi \\omega_2/\\omega_1}\\). g Complex vector length 2 holding invariants e Complex vector length 3.  \\(e_1\\), \\(e_2\\),       \\(e_3\\) defined       $$e_1=\\wp(\\omega_1/2)m\\qquad e_2=\\wp(\\omega_2/2),\\qquad \te_3=\\wp(\\omega_3/2)$$     \\(\\omega_3\\) defined     \\(\\omega_1+\\omega_2+\\omega_3=0\\). Note \\(e\\)s also defined three roots     \\(x^3-g_2x-g_3=0\\); method used     isolation roots may returned wrong order. Delta quantity \\(g_2^3-27g_3^2\\), often       denoted \\(\\Delta\\) Eta Complex vector length 3 often denoted       \\(\\eta\\).        \\(\\eta=(\\eta_1,\\eta_2,\\eta_3)\\) defined       terms Weierstrass zeta function       \\(\\eta_i=\\zeta(\\omega_i)\\) \\(=1,2,3\\). Note name element capitalized avoid confusion       function eta() .AnS Boolean, TRUE corresponding real       invariants, per Abramowitz Stegun given character string indicating parameter supplied.       Currently, one “o” (omega),  “g”       (invariants)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/parameters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parameters for Weierstrass's P function — parameters","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameters for Weierstrass's P function — parameters","text":"","code":"## Example 6, p665, LHS  parameters(g=c(10,2)) #> $Omega #> [1] 1.003847+0.00000i 0.000000+1.09797i #> attr(,\"class\") #> [1] \"primitive\" #>  #> $q #> [1] 0.03218824+0i #>  #> $e #>         e1         e2         e3  #>  1.6729816 -0.2033642 -1.4696174  #>  #> $g #> [1] 10  2 #>  #> $Delta #> [1] 892 #>  #> $Eta #> [1]  0.7988783+0.0000000i  0.0000000-0.6909934i -0.7988783+0.6909934i #>  #> $is.AnS #> [1] FALSE #>  #> $given #> [1] \"g\" #>  #> attr(,\"class\") #> [1] \"parameters\"  ## Not clear to me how AMS-55 justify 7 sig figs   ## Example 7, p665, RHS  a <- parameters(g=c(7,6)) ;  attach(a)  c(omega2=Omega[1],omega2dash=Omega[1]+Omega[2]*2) #>                     omega2                 omega2dash  #> 9.957998e-01+2.220446e-16i 1.110223e-16+2.332418e+00i     ## verify 18.3.37:   Eta[2]*Omega[1]-Eta[1]*Omega[2]   #should be close to pi*1i/2 #> [1] 0-1.570796i   ## from Omega to g and and back; ## following should be equivalent to c(1,1i):  parameters(g=parameters(Omega=c(1,1i))$g)$Omega  #> [1] 1.83518e-30-1.000000e+00i 1.00000e+00+1.840095e-30i #> attr(,\"class\") #> [1] \"primitive\""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrappers for PARI functions — pari","title":"Wrappers for PARI functions — pari","text":"Wrappers three elliptic functions PARI","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrappers for PARI functions — pari","text":"","code":"P.pari(z,Omega,pari.fun=\"ellwp\",numerical=TRUE)"},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrappers for PARI functions — pari","text":"z Complex argument Omega Half periods pari.fun String giving name function passed     PARI.  Values ellwp, ellsigma, ellzeta,     acceptable Weierstrass \\(\\wp\\) function,     \\(\\sigma\\) function, \\(\\zeta\\) function     respectively numerical Boolean default TRUE meaning return     complex value returned PARI, FALSE meaning     return ascii string returned PARI","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wrappers for PARI functions — pari","text":"function calls PARI via R system() call.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrappers for PARI functions — pari","text":"Returns object attributes z.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Wrappers for PARI functions — pari","text":"http://www.parigp-home.de/","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Wrappers for PARI functions — pari","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Wrappers for PARI functions — pari","text":"Function translates input , example, “ellwp([1+1*,2+3*],1.111+5.1132*)” pipes string directly gp. PARI system clearly powerful syntax basic version using , (example) figure vectorize calls.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/pari.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrappers for PARI functions — pari","text":"","code":"if (FALSE)  #this in a dontrun environment because it requires pari/gp  z  <- seq(from=1,to=3+2i,len=34) p <- c(1,1i) plot(abs(P.pari(z=z,Omega=p) - P(z=z,Omega=p))) #> Error: object 'z' not found plot(zeta(z=z,params=parameters(Omega=p))- P.pari(z=z,Omega=c(p),pari.fun=\"ellzeta\")) #> Error: object 'z' not found   # \\dontrun{}"},{"path":"https://robinhankin.github.io/elliptic/reference/sn.html","id":null,"dir":"Reference","previous_headings":"","what":"Jacobi form of the elliptic functions — sn","title":"Jacobi form of the elliptic functions — sn","text":"Jacobian elliptic functions","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/sn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jacobi form of the elliptic functions — sn","text":"","code":"ss(u,m, ...) sc(u,m, ...) sn(u,m, ...) sd(u,m, ...) cs(u,m, ...) cc(u,m, ...) cn(u,m, ...) cd(u,m, ...) ns(u,m, ...) nc(u,m, ...) nn(u,m, ...) nd(u,m, ...) ds(u,m, ...) dc(u,m, ...) dn(u,m, ...) dd(u,m, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/sn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jacobi form of the elliptic functions — sn","text":"u Complex argument m Parameter ... Extra arguments, maxiter, passed     theta.?()","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/sn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Jacobi form of the elliptic functions — sn","text":"sixteen Jacobi elliptic functions.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/sn.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Jacobi form of the elliptic functions — sn","text":"M. Abramowitz . . Stegun 1965.  Handbook mathematical     functions. New York: Dover","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/sn.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Jacobi form of the elliptic functions — sn","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/sn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jacobi form of the elliptic functions — sn","text":"","code":"#Example 1, p579: nc(1.9965,m=0.64) #> [1] -1392.111 # (some problem here)  # Example 2, p579: dn(0.20,0.19) #> [1] 0.9962527  # Example 3, p579: dn(0.2,0.81) #> [1] 0.984056  # Example 4, p580: cn(0.2,0.81) #> [1] 0.9802785  # Example 5, p580: dc(0.672,0.36) #> [1] 1.174019  # Example 6, p580: Theta(0.6,m=0.36) #> [1] 0.9735688  # Example 7, p581: cs(0.53601,0.09) #> [1] 1.691832  # Example 8, p581: sn(0.61802,0.5) #> [1] 0.5645758  #Example 9, p581: sn(0.61802,m=0.5) #> [1] 0.5645758  #Example 11, p581: cs(0.99391,m=0.5) #> [1] 0.7499963 # (should be 0.75 exactly)  #and now a pretty picture:  n <- 300 K <- K.fun(1/2) f <- function(z){1i*log((z-1.7+3i)*(z-1.7-3i)/(z+1-0.3i)/(z+1+0.3i))} # f <- function(z){log((z-1.7+3i)/(z+1.7+3i)*(z+1-0.3i)/(z-1-0.3i))} x <- seq(from=-K,to=K,len=n) y <- seq(from=0,to=K,len=n) z <- outer(x,1i*y,\"+\")  view(x, y, f(sn(z,m=1/2)), nlevels=44, imag.contour=TRUE,      real.cont=TRUE, code=1, drawlabels=FALSE,      main=\"Potential flow in a rectangle\",axes=FALSE,xlab=\"\",ylab=\"\") rect(-K,0,K,K,lwd=3)"},{"path":"https://robinhankin.github.io/elliptic/reference/sqrti.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized square root — sqrti","title":"Generalized square root — sqrti","text":"Square root wrapper keeps answer real possible, coerces complex .","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/sqrti.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized square root — sqrti","text":"","code":"sqrti(x)"},{"path":"https://robinhankin.github.io/elliptic/reference/sqrti.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized square root — sqrti","text":"x Vector return square root ","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/sqrti.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized square root — sqrti","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/sqrti.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized square root — sqrti","text":"","code":"sqrti(1:10)  #real #>  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 #>  [9] 3.000000 3.162278 sqrti(-10:10) #coerced to complex (compare sqrt(-10:10)) #>  [1] 0.000000+3.162278i 0.000000+3.000000i 0.000000+2.828427i 0.000000+2.645751i #>  [5] 0.000000+2.449490i 0.000000+2.236068i 0.000000+2.000000i 0.000000+1.732051i #>  [9] 0.000000+1.414214i 0.000000+1.000000i 0.000000+0.000000i 1.000000+0.000000i #> [13] 1.414214+0.000000i 1.732051+0.000000i 2.000000+0.000000i 2.236068+0.000000i #> [17] 2.449490+0.000000i 2.645751+0.000000i 2.828427+0.000000i 3.000000+0.000000i #> [21] 3.162278+0.000000i sqrti(1i+1:10) #complex anyway #>  [1] 1.098684+0.4550899i 1.455347+0.3435607i 1.755317+0.2848488i #>  [4] 2.015329+0.2480984i 2.247111+0.2225079i 2.457922+0.2034239i #>  [7] 2.652458+0.1885044i 2.833925+0.1764338i 3.004612+0.1664108i #> [10] 3.166218+0.1579171i"},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":null,"dir":"Reference","previous_headings":"","what":"Jacobi theta functions 1-4 — theta","title":"Jacobi theta functions 1-4 — theta","text":"Computes Jacobi's four theta functions complex \\(z\\) terms parameter \\(m\\) \\(q\\).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jacobi theta functions 1-4 — theta","text":"","code":"theta1  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) theta2  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) theta3  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) theta4  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) theta.00(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) theta.01(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) theta.10(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) theta.11(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30, miniter=3) Theta (u, m, ...) Theta1(u, m, ...) H (u, m, ...) H1(u, m, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jacobi theta functions 1-4 — theta","text":"z,u Complex argument function ignore Dummy variable whose intention force user     name second argument either m q m seem name.   variable introduced     section 16.1, p569 q nome \\(q\\), defined section 16.27, p576 give.n Boolean default FALSE meaning return     function evaluation, TRUE meaning return two element     list, first element function evaluation, second element     number iterations used maxiter Maximum number iterations used.  Note     series generally converge quickly miniter Minimum number iterations guard premature     exit addend zero exactly ... functions take , extra arguments passed     theta1() et seq; notably, maxiter","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Jacobi theta functions 1-4 — theta","text":"Functions theta.00() et seq just wrappers   theta1() et seq, following Whittaker Watson's terminology   p487; notation appear Abramowitz Stegun. theta.11() = theta1() theta.10() = theta2() theta.00() = theta3() theta.01() = theta4()","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jacobi theta functions 1-4 — theta","text":"Returns complex-valued object attributes either   z, (m q), whichever recycled.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Jacobi theta functions 1-4 — theta","text":"M. Abramowitz . . Stegun 1965.  Handbook mathematical   functions.  New York: Dover","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Jacobi theta functions 1-4 — theta","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/theta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jacobi theta functions 1-4 — theta","text":"","code":"m <- 0.5 derivative <- function(small){(theta1(small,m=m)-theta1(0,m=m))/small} right.hand.side1 <- theta2(0,m=m)*theta3(0,m=m)*theta4(0,m=m) right.hand.side2 <- theta1.dash.zero(m)  derivative(1e-5) - right.hand.side1   # should be zero #> [1] -1.443168e-11 derivative(1e-5) - right.hand.side2   # should be zero #> [1] -1.443168e-11"},{"path":"https://robinhankin.github.io/elliptic/reference/theta.neville.html","id":null,"dir":"Reference","previous_headings":"","what":"Neville's form for the theta functions — theta.neville","title":"Neville's form for the theta functions — theta.neville","text":"Neville's notation theta functions per section 16.36 Abramowitz Stegun.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.neville.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neville's form for the theta functions — theta.neville","text":"","code":"theta.s(u, m, method = \"16.36.6\", ...) theta.c(u, m, method = \"16.36.6\", ...) theta.d(u, m, method = \"16.36.7\", ...) theta.n(u, m, method = \"16.36.7\", ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/theta.neville.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neville's form for the theta functions — theta.neville","text":"u Primary complex argument m Real parameter method Character string corresponding S's equation     numbering scheme ... Extra arguments passed method function,     maxiter","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.neville.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Neville's form for the theta functions — theta.neville","text":"reproduce relevant sections AMS-55 , convenience:  (\\(v=\\pi u/(2K)\\) \\(q=q(m)\\)).","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.neville.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Neville's form for the theta functions — theta.neville","text":"M. Abramowitz . . Stegun 1965.  Handbook mathematical   functions. New York: Dover","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.neville.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neville's form for the theta functions — theta.neville","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta.neville.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neville's form for the theta functions — theta.neville","text":"","code":"#Figure 16.4. m <- 0.5 K <- K.fun(m) Kdash <- K.fun(1-m) x <- seq(from=0,to=4*K,len=100) plot  (x/K,theta.s(x,m=m),type=\"l\",lty=1,main=\"Figure 16.4, p578\") points(x/K,theta.n(x,m=m),type=\"l\",lty=2) points(x/K,theta.c(x,m=m),type=\"l\",lty=3) points(x/K,theta.d(x,m=m),type=\"l\",lty=4) abline(0,0)     #plot a graph of something that should be zero:  x <- seq(from=-4,to=4,len=55)  plot(x,(e16.37.1(x,0.5)-theta.s(x,0.5)),pch=\"+\",main=\"error: note vertical scale\")   #now table 16.1 on page 582 et seq:  alpha <- 85  m <- sin(alpha*pi/180)^2 ## K <- ellint_Kcomp(sqrt(m))  K <- K.fun(m)  u <- K/90*5*(0:18)  u.deg <- round(u/K*90)  cbind(u.deg,\"85\"=theta.s(u,m))      # p582, last col.  #>       u.deg        85 #>  [1,]     0 0.0000000 #>  [2,]     5 0.2132177 #>  [3,]    10 0.4284434 #>  [4,]    15 0.6474349 #>  [5,]    20 0.8714648 #>  [6,]    25 1.1011162 #>  [7,]    30 1.3361236 #>  [8,]    35 1.5752683 #>  [9,]    40 1.8163399 #> [10,]    45 2.0561678 #> [11,]    50 2.2907234 #> [12,]    55 2.5152906 #> [13,]    60 2.7246942 #> [14,]    65 2.9135742 #> [15,]    70 3.0766867 #> [16,]    75 3.2092122 #> [17,]    80 3.3070473 #> [18,]    85 3.3670599 #> [19,]    90 3.3872870  cbind(u.deg,\"85\"=theta.n(u,m))      # p583, last col.  #>       u.deg       85 #>  [1,]     0 1.000000 #>  [2,]     5 1.016639 #>  [3,]    10 1.066184 #>  [4,]    15 1.147516 #>  [5,]    20 1.258756 #>  [6,]    25 1.397253 #>  [7,]    30 1.559573 #>  [8,]    35 1.741516 #>  [9,]    40 1.938152 #> [10,]    45 2.143900 #> [11,]    50 2.352647 #> [12,]    55 2.557921 #> [13,]    60 2.753098 #> [14,]    65 2.931653 #> [15,]    70 3.087425 #> [16,]    75 3.214899 #> [17,]    80 3.309465 #> [18,]    85 3.367648 #> [19,]    90 3.387287"},{"path":"https://robinhankin.github.io/elliptic/reference/theta1.dash.zero.html","id":null,"dir":"Reference","previous_headings":"","what":"Derivative of theta1 — theta1.dash.zero","title":"Derivative of theta1 — theta1.dash.zero","text":"Calculates \\(\\theta_1'\\) function either \\(m\\)   \\(k\\)","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta1.dash.zero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derivative of theta1 — theta1.dash.zero","text":"","code":"theta1.dash.zero(m, ...) theta1.dash.zero.q(q, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/theta1.dash.zero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derivative of theta1 — theta1.dash.zero","text":"m real parameter q Real parameter ... Extra arguments passed theta1() et seq, notably     maxiter","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta1.dash.zero.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Derivative of theta1 — theta1.dash.zero","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta1.dash.zero.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derivative of theta1 — theta1.dash.zero","text":"","code":"#Now, try and get 16.28.6, p576: theta1dash=theta2*theta3*theta4:  m <- 0.5 derivative <- function(small){(theta1(small,m=m)-theta1(0,m=m))/small} right.hand.side <-  theta2(0,m=m)*theta3(0,m=m)*theta4(0,m=m) derivative(1e-7)-right.hand.side #> [1] -1.44329e-15"},{"path":"https://robinhankin.github.io/elliptic/reference/theta1dash.html","id":null,"dir":"Reference","previous_headings":"","what":"Derivatives of theta functions — theta1dash","title":"Derivatives of theta functions — theta1dash","text":"First, second, third derivatives theta functions","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta1dash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derivatives of theta functions — theta1dash","text":"","code":"theta1dash(z, ignore = NULL, m = NULL, q = NULL, give.n = FALSE,      maxiter = 30, miniter=3) theta1dashdash(z, ignore = NULL, m = NULL, q = NULL, give.n = FALSE,      maxiter = 30,miniter=3) theta1dashdashdash(z, ignore = NULL, m = NULL, q = NULL, give.n = FALSE,      maxiter = 30,miniter=3)"},{"path":"https://robinhankin.github.io/elliptic/reference/theta1dash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derivatives of theta functions — theta1dash","text":"z Primary complex argument ignore Dummy argument force user name next     argument either m q m m documented theta1() q q documented theta1() give.n Boolean default FALSE meaning return     function evaluation, TRUE meaning return two element     list, first element function evaluation, second element     number iterations used maxiter Maximum number iterations miniter Minimum number iterations guard premature     exit addend zero exactly","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta1dash.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Derivatives of theta functions — theta1dash","text":"Uses direct expansion theta1() et seq","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta1dash.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Derivatives of theta functions — theta1dash","text":"M. Abramowitz . . Stegun 1965. Handbook Mathematical      Functions.  New York, Dover","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/theta1dash.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Derivatives of theta functions — theta1dash","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/theta1dash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derivatives of theta functions — theta1dash","text":"","code":"m <- 0.3+0.31i z <- seq(from=1,to=2+1i,len=7) delta <- 0.001 deriv.numer <- (theta1dashdash(z=z+delta,m=m) - theta1dashdash(z=z,m=m))/delta deriv.exact <- theta1dashdashdash(z=z+delta/2,m=m) abs(deriv.numer-deriv.exact) #> [1] 1.716548e-08 1.209901e-08 1.190115e-08 1.813467e-08 3.291486e-08 #> [6] 5.981474e-08 1.042222e-07"},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":null,"dir":"Reference","previous_headings":"","what":"Unimodular matrices — unimodular","title":"Unimodular matrices — unimodular","text":"Systematically generates unimodular matrices; numerical verification function's unimodularness","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unimodular matrices — unimodular","text":"","code":"unimodular(n) unimodularity(n,o, FUN, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unimodular matrices — unimodular","text":"n Maximum size entries matrices o Two element vector FUN Function whose unimodularity checked ... arguments passed FUN","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Unimodular matrices — unimodular","text":", ‘unimodular’ matrix size \\(2\\times 2\\),   integer entries determinant unity.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unimodular matrices — unimodular","text":"Function unimodular() returns array dimension   c(2,2,u) (u complicated function n).   Thus 3-slices (, [,,]) unimodular. Function unimodularity() returns result applying   FUN() unimodular transformations o.    function returns vector length dim(unimodular(n))[3];   FUN() unimodular roundoff neglected, elements   vector identical.","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Unimodular matrices — unimodular","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Unimodular matrices — unimodular","text":"function .primitive(), ‘unimodular’ may   determinant minus one.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/elliptic/reference/unimodular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unimodular matrices — unimodular","text":"","code":"unimodular(3) #> , , 1 #>  #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> , , 2 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    0    1 #>  #> , , 3 #>  #>      [,1] [,2] #> [1,]    1    2 #> [2,]    0    1 #>  #> , , 4 #>  #>      [,1] [,2] #> [1,]    2    1 #> [2,]    1    1 #>  #> , , 5 #>  #>      [,1] [,2] #> [1,]    1    3 #> [2,]    0    1 #>  #> , , 6 #>  #>      [,1] [,2] #> [1,]    3    2 #> [2,]    1    1 #>  #> , , 7 #>  #>      [,1] [,2] #> [1,]    2    3 #> [2,]    1    2 #>  #> , , 8 #>  #>      [,1] [,2] #> [1,]    3    1 #> [2,]    2    1 #>   o <- c(1,1i) plot(abs(unimodularity(3,o,FUN=g2.fun,maxiter=100)-g2.fun(o)))"},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualization of complex functions — view","title":"Visualization of complex functions — view","text":"Visualization complex functions using colour maps contours","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualization of complex functions — view","text":"","code":"view(x, y, z, scheme = 0, real.contour = TRUE, imag.contour = real.contour, default = 0, col=\"black\", r0=1, power=1, show.scheme=FALSE, ...)"},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualization of complex functions — view","text":"x,y Vectors showing real imaginary components complex     plane; functionality  arguments image() z Matrix complex values visualized scheme Visualization scheme used.  numeric value     interpreted one (numbered) provided schemes; see source     code details, add new schemes time time     code case dominate anything written . default zero corresponds Thaller (1998): see references.     colour (ie white background), set scheme     negative number. scheme correspond built-function,     switch() statement “drops ” provides     white background (use show just real imaginary contours;     value \\(-1\\) always give behaviour) numeric, scheme interpreted function     produces colour; see examples section .  See details section     tools make writing functions easier real.contour,imag.contour Boolean default TRUE     meaning draw contours constant \\(Re(z)\\) (resp: \\(Im(z)\\))     FALSE meaning draw default Complex value assumed colouration,     z takes NA infinite values; defaults zero.     Set NA substitution (ie plot z “”);     usually bad idea col Colour (sent contour()) r0 scheme=0, radius Riemann sphere used     Thaller power Defines slight generalization Thaller's scheme.     Use high values emphasize areas high modulus (white) low     modulus (black); use low values emphasize argument     whole function's domain. argument also applied schemes     makes sense show.scheme Boolean, default FALSE meaning     perform advertized visualize complex function;     TRUE meaning return function corresponding     value argument scheme ... Extra arguments passed image() contour()","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualization of complex functions — view","text":"examples given different values scheme intended   examples : user encouraged experiment passing   homemade colour schemes (indeed pass schemes   author). Scheme 0 implements ideas Thaller: complex plane mapped   Riemann sphere, coded North pole white   (indicating pole) South Pole black (indicating zero).    equator (, complex numbers modulus r0) maps   colours maximal saturation. Function view() includes several tools simplify   creation suitable functions passing scheme. include: breakup(): Breaks continuous map:     function(x){ifelse(x>1/2,3/2-x,1/2-x)} g(): maps positive real \\([0,1]\\):     function(x){0.5+atan(x)/pi} scale(): scales range \\([0,1]\\):     function(x){(x-min(x))/(max(x)-min(x))} wrap(): wraps phase \\([0,1]\\):     function(x){1/2+x/(2*pi)}","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualization of complex functions — view","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Visualization of complex functions — view","text":"Additional ellipsis arguments given image()   contour() (typically, nlevels).  resulting   warning() one function suppressed   suppressWarnings().","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Visualization of complex functions — view","text":"B. Thaller 1998. Visualization complex functions,   Mathematica Journal, 7(2):163–180","code":""},{"path":"https://robinhankin.github.io/elliptic/reference/view.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualization of complex functions — view","text":"","code":"n <- 100 x <- seq(from=-4,to=4,len=n) y <- x z <- outer(x,1i*y,\"+\") view(x,y,limit(1/z),scheme=2)  view(x,y,limit(1/z),scheme=18)    view(x,y,limit(1/z+1/(z-1-1i)^2),scheme=5)  view(x,y,limit(1/z+1/(z-1-1i)^2),scheme=17)   view(x,y,log(0.4+0.7i+log(z/2)^2),main=\"Some interesting cut lines\")    view(x,y,z^2,scheme=15,main=\"try finer resolution\")  view(x,y,sn(z,m=1/2+0.3i),scheme=6,nlevels=33,drawlabels=FALSE)   view(x,y,limit(P(z,c(1+2.1i,1.3-3.2i))),scheme=2,nlevels=6,drawlabels=FALSE)  view(x,y,limit(Pdash(z,c(0,1))),scheme=6,nlevels=7,drawlabels=FALSE)  view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=6,scheme=4,col=\"white\")   # Now an example with a bespoke colour function:   fun <- function(z){hcl(h=360*wrap(Arg(z)),c= 100 * (Mod(z) < 1))}  view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=6,scheme=fun)   view(scheme=10, show.scheme=TRUE) #> function (z)  #> { #>     hsv(h = wrap(Arg(z)), v = scale(exp(-Mod(z)))) #> } #> <bytecode: 0x55f6da0b08f8> #> <environment: 0x55f6dccc56a0>"}]
